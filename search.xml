<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>設計模式 (Software design pattern)</title>
      <link href="/2025/07/12/design-patterns/"/>
      <url>/2025/07/12/design-patterns/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-設計模式"><a href="#Python-設計模式" class="headerlink" title="Python 設計模式"></a>Python 設計模式</h1><p>這篇文章紀錄四種我學習過的 Python 設計模式，包含簡單範例、使用情境與心得。</p><blockquote><p><strong>四種模式</strong></p><ol><li>單例模式 (Singleton)</li><li>工廠模式 (Factory)</li><li>策略模式 (Strategy)</li><li>觀察者模式 (Observer)</li></ol></blockquote><hr><h2 id="🟢-單例模式-Singleton-Pattern"><a href="#🟢-單例模式-Singleton-Pattern" class="headerlink" title="🟢 單例模式 Singleton Pattern"></a>🟢 單例模式 Singleton Pattern</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>確保一個類別在全程只存在唯一一個實例。</p><h3 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h3><ul><li>設定檔管理</li><li>資源共用 (e.g., 日誌 Logger)</li><li>全域狀態控制</li></ul><h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLogger</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;建立 SingletonLogger 實例&quot;</span>)</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;執行 __init__()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">log1 = SingletonLogger()</span><br><span class="line">log2 = SingletonLogger()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;log1 is log2:&quot;</span>, log1 <span class="keyword">is</span> log2)</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建立 SingletonLogger 實例</span><br><span class="line">執行 <span class="built_in">__init__</span>()</span><br><span class="line">執行 <span class="built_in">__init__</span>()</span><br><span class="line">log1 is log2: True</span><br></pre></td></tr></table></figure><blockquote><p>在單例模式中，第一次建立 SingletonLogger() 時，會產生唯一一個「全域實例」。<br>後面不管呼叫幾次 SingletonLogger()，都會回傳同一個物件，記憶體位置完全相同。<br>也就是說：<br>整個程式只會有一個 Logger，大家共用這個唯一的「盒子」。</p></blockquote><hr><h2 id="🟢-工廠模式-Factory-Pattern"><a href="#🟢-工廠模式-Factory-Pattern" class="headerlink" title="🟢 工廠模式 Factory Pattern"></a>🟢 工廠模式 Factory Pattern</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>將「建立物件的邏輯」抽離到工廠方法，統一管理實例化流程。</p><h3 id="使用情境-1"><a href="#使用情境-1" class="headerlink" title="使用情境"></a>使用情境</h3><ul><li>根據參數決定建立哪個子類別</li><li>解耦「建立物件」與「使用物件」</li></ul><h3 id="範例程式碼-1"><a href="#範例程式碼-1" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span>:</span><br><span class="line">    animal_classes = &#123;</span><br><span class="line">        <span class="string">&quot;dog&quot;</span>: Dog,</span><br><span class="line">        <span class="string">&quot;cat&quot;</span>: Cat</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">animal_type</span>):</span><br><span class="line">        <span class="keyword">if</span> animal_type <span class="keyword">in</span> AnimalFactory.animal_classes:</span><br><span class="line">            <span class="keyword">return</span> AnimalFactory.animal_classes[animal_type]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;未知的動物種類&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">animal = AnimalFactory.create_animal(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(animal.speak())</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Woof</span><br></pre></td></tr></table></figure><blockquote><p>在工廠模式中，每次呼叫 AnimalFactory.create_animal()，都會根據你給的參數，產生一個新的動物物件。<br>同一種動物（例如 Dog）呼叫多次，也會創建多個不同的 Dog 實例，彼此互不影響。<br>也就是說：<br>工廠就像流水線，每次都造出新的產品，產品彼此獨立。</p></blockquote><hr><h2 id="🟢-策略模式-Strategy-Pattern"><a href="#🟢-策略模式-Strategy-Pattern" class="headerlink" title="🟢 策略模式 Strategy Pattern"></a>🟢 策略模式 Strategy Pattern</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>將「行為策略」封裝為獨立類別，執行時依據情境決定要用哪個策略。</p><h3 id="使用情境-2"><a href="#使用情境-2" class="headerlink" title="使用情境"></a>使用情境</h3><ul><li>動態切換演算法</li><li>行為多樣化的系統</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperCaseStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> data.upper()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LowerCaseStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> data.lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        <span class="variable language_">self</span>.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_strategy</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        <span class="variable language_">self</span>.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_strategy</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.strategy.execute(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">context = Context(UpperCaseStrategy())</span><br><span class="line"><span class="built_in">print</span>(context.execute_strategy(<span class="string">&quot;Hello Strategy&quot;</span>))</span><br><span class="line"></span><br><span class="line">context.set_strategy(LowerCaseStrategy())</span><br><span class="line"><span class="built_in">print</span>(context.execute_strategy(<span class="string">&quot;Hello Strategy&quot;</span>))</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO STRATEGY</span><br><span class="line">hello strategy</span><br></pre></td></tr></table></figure><blockquote><p>在策略模式中，每次 CreditCardPayment() 都會建立一個新的「策略物件」，<br>ShoppingCart() 也每次產生一個新的購物車，<br>不會共用同一個實例，也就是說：<br>策略物件和購物車都是獨立的！</p></blockquote><hr><h2 id="🟢-觀察者模式-Observer-Pattern"><a href="#🟢-觀察者模式-Observer-Pattern" class="headerlink" title="🟢 觀察者模式 Observer Pattern"></a>🟢 觀察者模式 Observer Pattern</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>當主題狀態改變時，自動通知所有依賴它的觀察者。</p><h3 id="使用情境-3"><a href="#使用情境-3" class="headerlink" title="使用情境"></a>使用情境</h3><ul><li>事件通知</li><li>資料監聽</li><li>訂閱&#x2F;發布系統</li></ul><h3 id="範例程式碼-2"><a href="#範例程式碼-2" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 收到通知: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_observer</span>(<span class="params">self, observer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify_observers</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> <span class="variable language_">self</span>.observers:</span><br><span class="line">            observer.update(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">chat_room = ChatRoom()</span><br><span class="line">user1 = User(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">user2 = User(<span class="string">&quot;小美&quot;</span>)</span><br><span class="line"></span><br><span class="line">chat_room.add_observer(user1)</span><br><span class="line">chat_room.add_observer(user2)</span><br><span class="line"></span><br><span class="line">chat_room.notify_observers(<span class="string">&quot;今天有新活動！&quot;</span>)</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明 收到通知: 今天有新活動！</span><br><span class="line">小美 收到通知: 今天有新活動！</span><br></pre></td></tr></table></figure><blockquote><p>在觀察者模式中，每次 User() 都會建立一個新的「觀察者物件」，<br>ChatRoom() 也可以建立多個聊天室，彼此沒有關聯。<br>當聊天室呼叫 notify_observers() 時，會通知它自己「清單裡的觀察者」。<br>也就是說：<br>每個聊天室都維護自己的訂閱清單，觀察者和主題都是獨立物件，沒有共享同一個實例。</p></blockquote><hr><h2 id="✨-小結"><a href="#✨-小結" class="headerlink" title="✨ 小結"></a>✨ 小結</h2><p>這四種模式是物件導向程式設計中最經典的設計模式：</p><ul><li>單例：只有一個實例</li><li>工廠：統一建立流程</li><li>策略：行為可替換</li><li>觀察者：自動通知訂閱者</li></ul><table><thead><tr><th align="center">設計模式</th><th align="center">主要特點</th><th align="center">適用情境</th><th align="center">物件產生方式</th></tr></thead><tbody><tr><td align="center"><strong>單例模式</strong></td><td align="center">保證一個類別只有一個實例，並提供全局唯一的存取點。</td><td align="center">需要全局唯一資源或管理器，例如設定管理、日誌記錄器等。</td><td align="center">第一次建立時創建，之後重複使用同一實例。</td></tr><tr><td align="center"><strong>工廠模式</strong></td><td align="center">封裝物件創建邏輯，根據參數決定要建立哪一種物件，讓使用者不用直接接觸具體類別。</td><td align="center">需要根據條件動態生成不同類型物件，降低使用者與物件具體類別的耦合。</td><td align="center">每次呼叫都會新建不同物件。</td></tr><tr><td align="center"><strong>策略模式</strong></td><td align="center">將算法或行為封裝成獨立物件，並讓它們可互換，使得系統在運行時能動態切換算法。</td><td align="center">需要靈活切換算法或行為，避免條件分支過多。</td><td align="center">每次使用時新建策略物件，不同策略互相獨立。</td></tr><tr><td align="center"><strong>觀察者模式</strong></td><td align="center">建立一對多關係，當主題狀態改變時，自動通知所有訂閱者，達成鬆耦合的事件傳遞。</td><td align="center">事件驅動、發布訂閱系統、即時更新通知等場景。</td><td align="center">主題與觀察者皆可多次建立，互為獨立物件。</td></tr></tbody></table><p>未來如果專案規模變大，這些模式能幫助：</p><ul><li><p>✅ 降低耦合度（大家不再黏在一起）</p><blockquote><p>這些模式會強迫你把各種責任分散開來，<br>物件之間不需要互相知道彼此內部細節，<br>就像不同部門只透過「公開的接口」溝通，<br>大幅減少改一個功能導致整個系統崩潰的風險。</p></blockquote></li><li><p>✅ 提高可維護性（東西更好修、更好改）</p><blockquote><p>有了清晰的模式，每個部分都只負責一種角色，<br>你要修 bug 或調整邏輯時，可以聚焦在單一地方，<br>不用像無頭蒼蠅一樣到處追查影響範圍。<br>也方便新人上手，因為架構清楚一目了然。</p></blockquote></li><li><p>✅ 提升擴展彈性（新功能不再痛苦）</p><blockquote><p>當業務成長、需求變化時，<br>這些模式讓你用「替換」或「新增」的方式擴展功能，<br>不必動原本穩定的代碼：</p></blockquote></li><li><p>工廠模式：多增加一種產品類別即可</p></li><li><p>策略模式：多一個演算法就 plug-in</p></li><li><p>觀察者模式：隨時加訂閱者、移訂閱者</p></li><li><p>單例模式：確保全域只有一個資源</p></li></ul><hr><p>技術與應用方法：<br>Python（OOP 與 Design Pattern）、VS Code（Python Extension）、互動式 CLI（範例測試）</p><h2 id="📝心得："><a href="#📝心得：" class="headerlink" title="📝心得："></a>📝心得：</h2><blockquote><p>一開始對 <code>__new__()</code>、工廠模式的「字典映射類別」還有策略模式「注入策略物件」這種寫法有點陌生，看起來超抽象，不太確定「為什麼要多繞一層」，但慢慢測試、比對記憶體位置，就理解到它們的用意，這次練習也算是把「抽象的設計模式」變成「具體的練習案例」，實際跑一遍後真的對日後專案會有很大幫助，不管是要降低耦合度、提高可維護性、還是做功能擴展，都比單純 procedural code 更直覺清晰。如果未來要用到更大型的框架（像 Django、Flask、.NET Core），這些模式也能直接套用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技術筆記 </tag>
            
            <tag> (作者自學用) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌐 | 網站健康監控平台</title>
      <link href="/2025/07/05/UrlHealthMonitor/"/>
      <url>/2025/07/05/UrlHealthMonitor/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-NET-URL-Health-Monitor-以-Docker-部署的網站監控服務"><a href="#🚀-NET-URL-Health-Monitor-以-Docker-部署的網站監控服務" class="headerlink" title="🚀 .NET URL Health Monitor - 以 Docker 部署的網站監控服務"></a>🚀 .NET URL Health Monitor - 以 Docker 部署的網站監控服務</h1><blockquote><p>這是一個基於 .NET 8 的 URL 健康檢查服務，提供即時監控結果與可視化儀表板，支援 Docker 容器化部署。</p></blockquote><p>►  「 <a href="https://github.com/reedlin2002/UrlHealthMonitor">GITHUB</a> 」</p><hr><h2 id="💡-專案緣起"><a href="#💡-專案緣起" class="headerlink" title="💡 專案緣起"></a>💡 專案緣起</h2><p>在現代化的網站運維中，服務的可用性監控至關重要。在日常網站維運中，我們常需要定期檢查多個 URL 的可用性，並記錄歷史狀態供追蹤。本專案希望：</p><ul><li>自動化監控：每 30 秒自動檢查所有註冊的 URL</li><li>視覺化儀表板：以簡易 Web UI 呈現最近監控結果</li><li>簡易管理：CLI 指令快速管理監控清單、使用 SQLite 儲存歷史資料</li><li>提供容器化部署：Docker 一鍵部署，跨平台支援</li></ul><hr><h2 id="🛠️-專案技術"><a href="#🛠️-專案技術" class="headerlink" title="🛠️ 專案技術"></a>🛠️ 專案技術</h2><p>🟢 後端核心</p><blockquote><p>框架：.NET 8 Worker Service + ASP.NET Minimal API<br>語言：C#（Async&#x2F;Await + 依賴注入）<br>資料庫：SQLite 輕量級資料庫</p></blockquote><p>🟡 測試與品質</p><blockquote><p>測試框架：xUnit + FluentAssertions<br>開發方法：採用 TDD 思維</p></blockquote><p>🟣 前端</p><blockquote><p>介面：簡易 Web Dashboard<br>技術：HTML5 + CSS3 + Vanilla JavaScript</p></blockquote><p>🟠 部署運維</p><blockquote><p>容器化：Docker<br>環境支援：Linux &#x2F; Windows &#x2F; macOS</p></blockquote><hr><h2 id="⚙️-執行方式"><a href="#⚙️-執行方式" class="headerlink" title="⚙️ 執行方式"></a>⚙️ 執行方式</h2><h3 id="開發模式-本機執行"><a href="#開發模式-本機執行" class="headerlink" title="開發模式 (本機執行)"></a>開發模式 (本機執行)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dotnet run -- add &lt;URL&gt;       # 新增要監控的 URL</span><br><span class="line">dotnet run -- list            # 列出所有 URL</span><br><span class="line">dotnet run -- remove &lt;ID&gt;     # 移除指定 URL</span><br><span class="line">dotnet run -- serve           # 啟動 Web UI</span><br></pre></td></tr></table></figure><p>打開 <a href="http://localhost:5000/">http://localhost:5000</a> 查看 Dashboard。</p><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 建置映像</span><br><span class="line">docker build -t urlhealthmonitor .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 執行容器</span><br><span class="line">docker run -d -p 5001:5000 --name urlhealthmonitor urlhealthmonitor</span><br></pre></td></tr></table></figure><p>打開 <a href="http://localhost:5001/">http://localhost:5001</a> 查看 Dashboard。</p><hr><h2 id="🌐-實際示範"><a href="#🌐-實際示範" class="headerlink" title="🌐 實際示範"></a>🌐 實際示範</h2><div id="gallery">  <a href="/images/UrlHealthMonitor-01.png">    <img src="/images/UrlHealthMonitor-01.png" alt="記帳頁面" style="max-width: 600px;">  </a></div><hr><h2 id="🧪-TDD-測試"><a href="#🧪-TDD-測試" class="headerlink" title="🧪 TDD 測試"></a>🧪 TDD 測試</h2><h3 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test</span><br></pre></td></tr></table></figure><p>測試範圍：</p><ul><li>HTTP 請求狀態檢查</li><li>超時處理</li><li>資料庫操作</li></ul><hr><h2 id="🚀-未來擴展"><a href="#🚀-未來擴展" class="headerlink" title="🚀 未來擴展"></a>🚀 未來擴展</h2><ul><li>RESTful API 支援</li><li>整合通知 (EMAIL &#x2F; LINE)</li><li>監控數據視覺化</li></ul><hr><p>技術與應用方法：<br>.NET 8、C#（Async&#x2F;Await + 依賴注入）、SQLite、xUnit + FluentAssertions（TDD 開發流程）、Docker、HttpClient（網站監控）、CLI 、JavaScript + HTML&#x2F;CSS</p><h2 id="📝-心得"><a href="#📝-心得" class="headerlink" title="📝 心得"></a>📝 心得</h2><blockquote><p>針對TDD、HTTP協議這兩個技術練習了這個「HTTP狀態碼偵測器」，在撰寫程式碼的過程中因為使用的是很久沒碰的 C# 一開始確實有些生疏，經常忘記變數宣告的語法規則，但隨著練習逐漸找回手感。在Docker部屬上，常常遇到檔案不知道放哪裡的問題，不過經過一番ChatGPT的協助和一番研究也是弄好了～也靠著TDD學會了更可靠的程式碼，先用測試再寫功能，確保程式碼符合預期，減少BUG，培養良好的開發習慣</p></blockquote><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>  lightGallery(document.getElementById("gallery"), {    plugins: [lgZoom],    speed: 300,    zoom: true  });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧠 | 聊天機器人</title>
      <link href="/2025/06/25/ollama/"/>
      <url>/2025/06/25/ollama/</url>
      
        <content type="html"><![CDATA[<h1 id="用-Ollama-LangChain-打造本地-AI-工具型-Agent（含-RAG-文件問答）"><a href="#用-Ollama-LangChain-打造本地-AI-工具型-Agent（含-RAG-文件問答）" class="headerlink" title="用 Ollama + LangChain 打造本地 AI 工具型 Agent（含 RAG 文件問答）"></a>用 Ollama + LangChain 打造本地 AI 工具型 Agent（含 RAG 文件問答）</h1><blockquote><p>這是一個我為了學習與實驗所做的小型 side project，目的是了解如何在本地端結合 LLM、LangChain 工具框架與 RAG（檢篩式問答）系統，實作出一個能夠回答問題、查天氣、計算數學，甚至查詢本地知識檔案的智能助手。</p></blockquote><hr><h2 id="🔧-專案目標"><a href="#🔧-專案目標" class="headerlink" title="🔧 專案目標"></a>🔧 專案目標</h2><blockquote><p>✫️ 建立一個 AI 助手系統，具備：</p></blockquote><ul><li>多工具整合能力（如計算器、天氣查詢）</li><li>基於本地文字檔的知識問答功能（RAG）</li><li>使用自己裝好模型的 Ollama + LangChain Agent 結構</li></ul><hr><h2 id="系統流程圖"><a href="#系統流程圖" class="headerlink" title="系統流程圖"></a>系統流程圖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用者輸入問題</span><br><span class="line">    ↓</span><br><span class="line">判斷是否需呼叫工具？</span><br><span class="line">    ↓</span><br><span class="line">【需要工具的流程】                                           【不需要工具的流程】</span><br><span class="line">LangChain Agent 分析                 直接呼叫 LLM → LLM 生成回答 → 輸出結果給使用者</span><br><span class="line">    ↓</span><br><span class="line">選擇對應 Tool</span><br><span class="line">    ├ Calculator Tool</span><br><span class="line">    │</span><br><span class="line">    ├ Get Weather Tool  </span><br><span class="line">    │</span><br><span class="line">    └ RAG Tool</span><br><span class="line">        ├ TextLoader 載入檔案</span><br><span class="line">        ├ Text Splitter 切段</span><br><span class="line">        ├ HuggingFaceEmbeddings 向量化</span><br><span class="line">        └ FAISS 向量資料庫檢索</span><br><span class="line">    ↓</span><br><span class="line">Ollama LLM (Mistral)</span><br><span class="line">    ↓</span><br><span class="line">生成回答</span><br><span class="line">    ↓</span><br><span class="line">輸出結果給使用者</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="套件與技術"><a href="#套件與技術" class="headerlink" title="套件與技術"></a>套件與技術</h2><table><thead><tr><th>技術</th><th>用途</th></tr></thead><tbody><tr><td><a href="https://www.langchain.com/">LangChain</a></td><td>組合 Agent 與工具</td></tr><tr><td><a href="https://ollama.com/">Ollama</a> (Mistral)</td><td>本地執行的大語言模型</td></tr><tr><td><code>Tool</code> (LangChain)</td><td>包裝可被 Agent 呼叫的功能</td></tr><tr><td><code>RetrievalQA</code></td><td>建立基於文字檔的問答鏈</td></tr><tr><td><code>FAISS</code></td><td>高效的向量資料庫</td></tr><tr><td><code>HuggingFaceEmbeddings</code></td><td>將文本轉換為向量的埋入模型</td></tr><tr><td><code>TextLoader</code>, <code>CharacterTextSplitter</code></td><td>處理本地文件內容</td></tr></tbody></table><hr><h3 id="核心程式"><a href="#核心程式" class="headerlink" title="核心程式"></a>核心程式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ⭐️ LLM 模型（使用 Ollama + Mistral）</span></span><br><span class="line">llm = OllamaLLM(model=<span class="string">&quot;mistral&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⭐️ 建立工具：Calculator / Get Weather</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculator</span>(<span class="params">query</span>): <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">eval</span>(query))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weather</span>(<span class="params">city</span>): <span class="keyword">return</span> &#123;<span class="string">&quot;台北&quot;</span>:<span class="string">&quot;晴天30度&quot;</span>&#125;.get(city, <span class="string">&quot;查無資料&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⭐️ RAG 工具：透過 FAISS 向量庫查詢本地 data.txt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_rag_tool</span>():</span><br><span class="line">    loader = TextLoader(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">    docs = loader.load()</span><br><span class="line">    splits = CharacterTextSplitter(chunk_size=<span class="number">500</span>).split_documents(docs)</span><br><span class="line">    embeddings = HuggingFaceEmbeddings()</span><br><span class="line">    vectorstore = FAISS.from_documents(splits, embeddings)</span><br><span class="line">    retriever = vectorstore.as_retriever()</span><br><span class="line">    rag_chain = RetrievalQA.from_chain_type(llm, retriever=retriever)</span><br><span class="line">    <span class="keyword">return</span> Tool(name=<span class="string">&quot;rag_tool&quot;</span>, func=rag_chain.run, description=<span class="string">&quot;查詢本地知識文件&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="整合-Tool-與-Agent"><a href="#整合-Tool-與-Agent" class="headerlink" title="整合 Tool 與 Agent"></a>整合 Tool 與 Agent</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tools = [</span><br><span class="line">    Tool.from_function(<span class="string">&quot;calculator&quot;</span>, calculator, <span class="string">&quot;數學計算&quot;</span>),</span><br><span class="line">    Tool.from_function(<span class="string">&quot;get_weather&quot;</span>, get_weather, <span class="string">&quot;天氣查詢&quot;</span>),</span><br><span class="line">    build_rag_tool()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    agent_type=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,</span><br><span class="line">    handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">    verbose=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><h3 id="查詢天氣：台北"><a href="#查詢天氣：台北" class="headerlink" title="查詢天氣：台北"></a>查詢天氣：台北</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：查台北天氣</span><br><span class="line">🧩 使用 [Agent] 處理中...</span><br><span class="line"></span><br><span class="line">Action: get_weather</span><br><span class="line">Action Input: <span class="string">&#x27;Taipei&#x27;</span></span><br><span class="line">Observation: 晴天，30 度</span><br><span class="line">Final Answer: 晴天，30 度</span><br></pre></td></tr></table></figure><div id="gallery1">  <a href="/images/ollama-Taipei.png">    <img src="/images/ollama-Taipei.png" alt="查詢天氣：台北" style="max-width: 600px;">  </a></div><hr><h3 id="查詢天氣：高雄"><a href="#查詢天氣：高雄" class="headerlink" title="查詢天氣：高雄"></a>查詢天氣：高雄</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：高雄幾度</span><br><span class="line"></span><br><span class="line">Action: get_weather</span><br><span class="line">Action Input: <span class="string">&#x27;高雄&#x27;</span></span><br><span class="line">Observation: 小雨，27 度</span><br><span class="line">Final Answer: 高雄今天是小雨且27度。</span><br></pre></td></tr></table></figure><div id="gallery2">  <a href="/images/ollama-KAO.png">    <img src="/images/ollama-KAO.png" alt="查詢天氣：高雄" style="max-width: 600px;">  </a></div><hr><h3 id="數學運算"><a href="#數學運算" class="headerlink" title="數學運算"></a>數學運算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：12 * 3 + 5 是多少？</span><br><span class="line"></span><br><span class="line">Action: calculator</span><br><span class="line">Action Input: <span class="string">&#x27;12 * 3 + 5&#x27;</span></span><br><span class="line">Observation: 45</span><br><span class="line">Final Answer: 結果為45。</span><br></pre></td></tr></table></figure><div id="gallery3">  <a href="/images/ollama-math.png">    <img src="/images/ollama-math.png" alt="數學運算" style="max-width: 600px;">  </a></div><hr><h3 id="問文件內容"><a href="#問文件內容" class="headerlink" title="問文件內容"></a>問文件內容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：文件內容有提到什麼？</span><br><span class="line"></span><br><span class="line">Action: rag_tool</span><br><span class="line">Observation: 文件提到了台灣、台北、自然風景、語言（台語、閩南語、客家話）、夜市與珍珠奶茶等。</span><br><span class="line">Final Answer: 這份文件提到了台灣、台北、自然風景、文化與語言、以及夜市文化。</span><br></pre></td></tr></table></figure><div id="gallery4">  <a href="/images/ollama-RAG.png">    <img src="/images/ollama-RAG.png" alt="問文件內容" style="max-width: 600px;">  </a></div><hr><h3 id="自然對話"><a href="#自然對話" class="headerlink" title="自然對話"></a>自然對話</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：你好</span><br><span class="line"></span><br><span class="line">💬 使用 LLM 直接回答...</span><br><span class="line">🤖 回答：您好！讓我有幸為您提供服務。如果您有任何問題，請隨時告知，我會盡力幫助您解決。</span><br></pre></td></tr></table></figure><div id="gallery5">  <a href="/images/ollama-LLM.png">    <img src="/images/ollama-LLM.png" alt="自然對話" style="max-width: 600px;">  </a></div><hr><h2 id="📁-結構"><a href="#📁-結構" class="headerlink" title="📁 結構"></a>📁 結構</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my-ollama/</span><br><span class="line">│</span><br><span class="line">├── main.py</span><br><span class="line">├── data.txt       ← 本地知識庫文字檔</span><br><span class="line">├── .venv/         ← 虛擬環境</span><br><span class="line">├── requirements.txt</span><br></pre></td></tr></table></figure><hr><p>技術包含：<br>Python、LangChain、Ollama、Mistral 模型、FAISS、HuggingFace Embeddings、RetrievalQA、自訂工具函數（Calculator、Get Weather）</p><h2 id="📝-心得"><a href="#📝-心得" class="headerlink" title="📝 心得"></a>📝 心得</h2><blockquote><p>第一次接觸LLM、LangChain、Agent 花了2、3天完成這個小應用。<br>這個 project 幫助我：</p></blockquote><ul><li>熟悉 LangChain 中 Tool&#x2F;Agent 的用法</li><li>練習本地模型 Ollama 的載入與使用</li><li>理解 RAG 的流程從文件切分到檢篩的設計邏輯</li></ul><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>    lightGallery(document.getElementById("gallery1"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery2"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery3"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery4"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery5"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🤖 | 記帳小管家</title>
      <link href="/2025/06/18/expenses/"/>
      <url>/2025/06/18/expenses/</url>
      
        <content type="html"><![CDATA[<h1 id="一個結合-React-前端與-Flask-後端的個人記帳專案"><a href="#一個結合-React-前端與-Flask-後端的個人記帳專案" class="headerlink" title="一個結合 React 前端與 Flask 後端的個人記帳專案"></a>一個結合 React 前端與 Flask 後端的個人記帳專案</h1><blockquote><p>基於 Flask + React，快速打造可視化、具本地儲存功能的個人記帳工具，部署在 Render 免費平台。</p></blockquote><div id="gallery">  <a href="/images/expenses_1.png">    <img src="/images/expenses_1.png" alt="記帳頁面" style="max-width: 600px;">  </a></div><hr><h2 id="執行目標"><a href="#執行目標" class="headerlink" title="執行目標"></a>執行目標</h2><p>希望做出一款簡單的記帳小工具，具有以下功能：</p><ul><li>支援每日紀錄多筆支出</li><li>直覺的欄位輸入介面</li><li>統計支出、圖表呈現</li><li>可依週切換檢視區間</li><li>支援本地儲存（localStorage）</li><li>無須登入註冊，輕量、單機可用</li></ul><h2 id="技術使用"><a href="#技術使用" class="headerlink" title="技術使用"></a>技術使用</h2><ul><li><strong>Flask</strong>: Python 後端 Web Framework</li><li><strong>HTML + React (CDN)</strong>: 前端創建主畫面</li><li><strong>Babel (CDN)</strong>: 讓我們直接在 HTML 中操作 JSX</li><li><strong>CSS</strong>: 自定義樣式</li><li><strong>Render.com</strong>: 免費部署 Platform</li></ul><h3 id="Flask-後端"><a href="#Flask-後端" class="headerlink" title="Flask 後端"></a>Flask 後端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template  <span class="comment"># 匯入 Flask 框架與頁面渲染函式</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 匯入 os 模組，用於抓取環境變數</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  <span class="comment"># 初始化 Flask 應用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)  </span><span class="comment"># 當用戶訪問根目錄 `/` 時</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)  <span class="comment"># 回傳前端頁面（templates/index.html）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 讓 Flask 可以在本地測試，也能被 Render 部署（抓環境變數 PORT）</span></span><br><span class="line">    port = <span class="built_in">int</span>(os.environ.get(<span class="string">&quot;PORT&quot;</span>, <span class="number">5000</span>))</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=port)</span><br></pre></td></tr></table></figure><h3 id="前端-HTML-React"><a href="#前端-HTML-React" class="headerlink" title="前端 HTML + React"></a>前端 HTML + React</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;css/style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- React &amp; Babel CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Chart.js for data visualization --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 載入應用程式主程式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;js/app.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>React 使用 CDN 形式加載，用 <code>babel</code> 直接執行 JSX 程式</p></blockquote><h2 id="React-應用程式-core"><a href="#React-應用程式-core" class="headerlink" title="React 應用程式 core"></a>React 應用程式 core</h2><h3 id="資料儲存方式"><a href="#資料儲存方式" class="headerlink" title="資料儲存方式"></a>資料儲存方式</h3><table><thead><tr><th>元件</th><th>功能說明</th></tr></thead><tbody><tr><td><code>App</code></td><td>主控元件，負責整體狀態與資料流處理</td></tr><tr><td><code>ExpenseForm</code></td><td>表單元件，讓使用者輸入支出項目與金額</td></tr><tr><td><code>ExpenseList</code></td><td>顯示當日支出紀錄，並可即時動態更新</td></tr><tr><td><code>WeeklyChart</code></td><td>使用柱狀圖呈現每日支出金額，支援週次切換與點擊查看</td></tr></tbody></table><h3 id="架構設計"><a href="#架構設計" class="headerlink" title="架構設計"></a>架構設計</h3><ul><li>資料儲存：所有紀錄保存在 localStorage，依照日期分類。</li><li>畫面互動：輸入資料即時更新列表與圖表，並保留在本地。</li><li>視覺化統計：使用 Chart.js 呈現每日總支出，支援週次切換與點擊查看。</li></ul><p>技術包含：<br>Python、Flask、HTML、React、Babel、JavaScript、Chart.js、CSS、localStorage、Render.com</p><h2 id="📝-心得"><a href="#📝-心得" class="headerlink" title="📝 心得"></a>📝 心得</h2><blockquote><p>這是一個簡單的 Flask + React 應用，Side Project。</p></blockquote><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>  lightGallery(document.getElementById("gallery"), {    plugins: [lgZoom],    speed: 300,    zoom: true  });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📕 | PDF Reader</title>
      <link href="/2025/06/09/program/"/>
      <url>/2025/06/09/program/</url>
      
        <content type="html"><![CDATA[<h1 id="PDF-Reader"><a href="#PDF-Reader" class="headerlink" title="PDF Reader"></a>PDF Reader</h1><blockquote><p>這是一個利用 RAG（Retrieval-Augmented Generation），做的 PDF 閱讀工具，方便從 PDF 文件中查詢資訊。</p></blockquote><hr><h2 id="技術架構"><a href="#技術架構" class="headerlink" title="技術架構"></a>技術架構</h2><ul><li>使用 Streamlit 做前端互動頁面，讓使用者上傳 PDF 並輸入問題。</li><li>使用 PyPDF2 讀取 PDF 內容，jieba 進行分段。</li><li>使用 SentenceTransformer 將文本轉成向量，再用 FAISS 建立向量搜尋索引。</li><li>利用 Hugging Face 中文問答模型，從搜尋到的相關段落中找答案。</li><li>將答案與參考段落顯示給使用者。</li></ul><p>RAG 技術透過檢索（Retrieval）+ 增強上下文（Augmentation）+ 生成回答（Generation）三步驟，讓模型根據提供的內容產出準確的答案。</p><hr><h2 id="🧩-RAG-流程-簡易"><a href="#🧩-RAG-流程-簡易" class="headerlink" title="🧩 RAG 流程 (簡易)"></a>🧩 RAG 流程 (簡易)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提問 → 檢索相關內容 → 合併為上下文 → 模型生成回答</span><br></pre></td></tr></table></figure><h3 id="1-Retrieval（檢索）"><a href="#1-Retrieval（檢索）" class="headerlink" title="1. Retrieval（檢索）"></a>1. Retrieval（檢索）</h3><ul><li>將 PDF 切成段落並建立向量表示（TF-IDF 或 embedding）</li><li>使用 cosine similarity 找出與問題最相關的段落</li></ul><h3 id="2-Augmentation（增強）"><a href="#2-Augmentation（增強）" class="headerlink" title="2. Augmentation（增強）"></a>2. Augmentation（增強）</h3><ul><li>將相關段落合併成上下文內容</li><li>與問題一起輸入給模型</li></ul><h3 id="3-Generation（生成）"><a href="#3-Generation（生成）" class="headerlink" title="3. Generation（生成）"></a>3. Generation（生成）</h3><ul><li>使用 Hugging Face 的中文 QA 模型回答問題</li></ul><hr><h2 id="系統流程圖"><a href="#系統流程圖" class="headerlink" title="系統流程圖"></a>系統流程圖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[PDF 上傳] → [文字解析] → [中文分段]</span><br><span class="line">                        ↓</span><br><span class="line">           [段落向量化（TF-IDF）]</span><br><span class="line">                        ↓</span><br><span class="line">         [使用者提問 → 問題向量化]</span><br><span class="line">                        ↓</span><br><span class="line">         [計算相似度 → 取前 3 段]</span><br><span class="line">                        ↓</span><br><span class="line">        [合併上下文 + question]</span><br><span class="line">                        ↓</span><br><span class="line">         [丟進 HuggingFace QA 模型]</span><br><span class="line">                        ↓</span><br><span class="line">                 [產生回答]</span><br></pre></td></tr></table></figure><hr><h2 id="程式"><a href="#程式" class="headerlink" title="程式"></a>程式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立段落的 TF-IDF 向量庫</span></span><br><span class="line">chunk_vectors = vectorizer.fit_transform(chunks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將使用者問題向量化</span></span><br><span class="line">query_vec = vectorizer.transform([user_question])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算問題與各段落相似度</span></span><br><span class="line">similarities = cosine_similarity(query_vec, chunk_vectors)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得前三個最高相似度段落索引</span></span><br><span class="line">top_indices = similarities.argsort()[-<span class="number">3</span>:][::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合成上下文</span></span><br><span class="line">top_chunks = [chunks[i] <span class="keyword">for</span> i <span class="keyword">in</span> top_indices]</span><br><span class="line">context = <span class="string">&quot;\n&quot;</span>.join(top_chunks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 丟給問答模型產生答案</span></span><br><span class="line">result = qa_pipeline(&#123;<span class="string">&quot;question&quot;</span>: user_question, <span class="string">&quot;context&quot;</span>: context&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>技術包含：<br>Python、Streamlit、PyPDF2、jieba、SentenceTransformers、FAISS、Hugging Face Transformers</p><h2 id="📝-心得"><a href="#📝-心得" class="headerlink" title="📝 心得"></a>📝 心得</h2><blockquote><p><strong>備註</strong>：這個程式是我學習 RAG 技術的初步嘗試，所以還有很多能夠優化的地方，請多指教。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📌 | LeetCode 學習記錄</title>
      <link href="/2025/06/06/dailyleetcode/"/>
      <url>/2025/06/06/dailyleetcode/</url>
      
        <content type="html"><![CDATA[<p>程式能力的提升離不開持續的練習。我會在這裡分享：</p><p>每日筆記 - 自己對題目的理解與應用<br>心得分享 - 刷題過程中的進度與收穫</p><table><thead><tr><th>✅</th><th>🉑</th><th>🚫</th></tr></thead><tbody><tr><td><strong>了解並寫出</strong></td><td><strong>寫出但不清楚</strong></td><td><strong>寫不出來</strong></td></tr></tbody></table><p>📌 <strong>LeetCode 記錄</strong></p><ul><li><strong>D1</strong> 🉑  #1  Two Sum <em>(GPT)</em></li><li><strong>D2</strong> 🉑  #9  Palindrome Number <em>(GPT)</em></li><li><strong>D3</strong> ✅  #13 Roman to Integer <em>(GPT)</em></li><li><strong>D4</strong> ✅  #1  Two Sum  </li><li><strong>D5</strong> ☕ <strong>休息</strong></li><li><strong>D6</strong> ✅  #9  Palindrome  <ul><li><code>[::-1]</code> ← Python 能用來順序相反</li></ul></li><li><strong>D7</strong> 🉑  #14 Longest Common Prefix  <ul><li><code>startswith(prefix)</code> ← 檢查字串是否「以 prefix 開頭」</li></ul></li><li><strong>D8</strong> 🉑  #14 Longest Common Prefix  <ul><li><code>if not 某東西:</code> ← 檢查 “某東西” 是否為空，如果是就執行</li></ul></li><li><strong>D9</strong> 🉑  #14 Longest Common Prefix  <ul><li><code>while not 某東西:</code> ← 檢查 “某東西” 為 True&#x2F;False，如果為 False 就執行</li></ul></li><li><strong>D10</strong> ✅  #14 Longest Common Prefix</li><li><strong>D11</strong> ✅  #14 Longest Common Prefix <em>(複習)</em></li><li><strong>D12</strong> 🚫  #20 Valid Parentheses  </li><li><strong>D13</strong> 🚫  #20 Valid Parentheses  <ul><li><code>&#123;&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;&#125;</code> ← 嘗試理解 mapping 對應關係</li></ul></li><li><strong>D14</strong> ☕ <strong>休息</strong></li><li><strong>D15</strong> 🚫  #20 Valid Parentheses<ul><li><code>&#123;&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;&#125;</code> ← 嘗試理解 mapping 對應關係</li></ul></li><li><strong>D16</strong> 🚫  #20 Valid Parentheses<ul><li><code>for i in s:</code> ← 直接遍歷字串中的每個字元</li></ul></li><li><strong>D17</strong> 🚫  #20 Valid Parentheses<ul><li><code>if i in mapping:</code> ← 檢查 i 是否是右括號（<code>)</code>,<code>]</code>, <code>&#125;</code>）</li><li><code>mapping[&quot;)&quot;]</code>  ← 會得到 <code>(</code>  (從mapping這個對應關係中)</li><li><code>stack[-1]</code> 意思是stack的堆疊的最上層 EX: <code>x=[ 10, 20, 30] x[-1]=30 x[-2]=20 x[-3]=10</code></li></ul></li><li><strong>D18</strong> 🉑  #20 Valid Parentheses</li><li><strong>D19</strong> 🉑  #20 Valid Parentheses<ul><li><code>stack.append</code>  ← 將資料放入堆疊頂端</li><li><code>stack.pop</code>     ← 將堆疊頂端資料移除</li></ul></li><li><strong>D20</strong> 🉑  #20 Valid Parentheses</li><li><strong>D21</strong> 🉑  #20 Valid Parentheses</li><li><strong>D22</strong> ✅  #20 Valid Parentheses</li><li><strong>D23</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>2025&#x2F;05&#x2F;07 回歸繼續寫<blockquote><p>self.val &#x3D; val        # 節點的數值，例如 1、2、3<br>self.next &#x3D; next      # 指向下一個節點的指標</p></blockquote></li></ul></li><li><strong>D24</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>ListNode(1) -&gt; ListNode(3) -&gt; ListNode(5)<blockquote><p>每個節點 (ListNode) 裡面都有：<br>.val：存放數值（1、3、5）<br>.next：指向下一個節點（或 None 表示結尾）</p></blockquote></li></ul></li><li><strong>D25</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>list1 &#x3D; 1 -&gt; 3 -&gt; 5、list2 &#x3D; 2 -&gt; 4 -&gt; 6<blockquote><p>比較 1 和 2 → 接 1 → list1 向前 → 結果：1<br>比較 3 和 2 → 接 2 → list2 向前 → 結果：1 → 2<br>比較 3 和 4 → 接 3 → …<br>一直到兩邊都走完 → 合併完成</p></blockquote></li></ul></li><li><strong>D26</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>🔚 dummy 是儲存「整條串列的起點」<br><br>🔧 current.next 是「不斷接節點的位置」</li></ul></li><li><strong>D27</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>✔️ dummy 是假節點，current 是用來構建新串列的指標</li><li>✔️ while 迴圈比較 list1 和 list2：<blockquote><p>每次比較 .val，把比較小的節點接到 current.next<br>然後那邊的 list 移動到下一個節點（list1 &#x3D; list1.next），再讓 current 自己也往前移（current &#x3D; current.next）</p></blockquote></li><li>✔️ 接剩下沒比完的節點，最後 return dummy.next 而不是 dummy</li></ul></li><li><strong>D28</strong> 🉑  #21 Merge Two Sorted Lists</li><li><strong>D29</strong> ✅  #21 Merge Two Sorted Lists</li><li><strong>D30</strong> ✅  #21 Merge Two Sorted Lists (review)</li><li><strong>D31</strong> ✅  #75 Sort Colors (Daily Question)</li><li><strong>D32</strong> 🚫  #26 Remove Duplicates from Sorted Array<ul><li>目標為輸出不重複結果 (應該是用i、j解決)</li></ul></li><li><strong>D33</strong> 🚫  #26 Remove Duplicates from Sorted Array<ul><li>找出不重複的元素</li><li>for j in range(1, len(nums)):<blockquote><p>從第二個元素開始找 j是掃描指標</p></blockquote></li><li>if nums[j] !&#x3D; nums[i]:<blockquote><p>比較當前掃描到的 nums[j] 跟上次保留的 nums[i]<br>如果不一樣 → 代表找到一個 新的不重複元素</p></blockquote></li><li>i +&#x3D; 1<br>nums[i] &#x3D; nums[j]<blockquote><p>把這個新元素「放到前面」來取代舊的重複元素</p></blockquote></li></ul></li><li><strong>D34</strong> 🉑  #26 Remove Duplicates from Sorted Array</li><li><strong>D35</strong> 🉑  #26 Remove Duplicates from Sorted Array<ul><li>邊掃描、邊把不重複的元素往前搬<blockquote><p>nums[0] 到 nums[i] 是 不重複且排序好的</p></blockquote></li></ul></li><li><strong>D36</strong> ✅  #26 Remove Duplicates from Sorted Array</li><li><strong>D37</strong> 🚫  #27 Remove Element</li><li><strong>D38</strong> 🉑  #27 Remove Element<ul><li>就地 (in-place) 移除所有等於 val 的元素，並回傳「移除後的陣列長度」</li></ul></li><li><strong>D39</strong> ✅  #27 Remove Element</li><li><strong>D40</strong> 🚫  #28 Find the Index of the First Occurrence in a String<ul><li>找出一段小字串，第一次在大字串中出現的位置</li></ul></li><li><strong>D41</strong> 🉑  #28 Find the Index of the First Occurrence in a String<ul><li>判斷<blockquote><p>haystack &#x3D; “TCodeLee”<br>haystack[0:3] → 取第 0、1、2 的字 → “TCo”<br>haystack[1:4] → 取第 1、2、3 的字 → “Cod”</p></blockquote></li></ul></li><li><strong>D42</strong> 🉑  #28 Find the Index of the First Occurrence in a String<ul><li>假設hatstack:LeetCode , needle:Lee<blockquote><p>for i in range(len(haystack) - len(needle) + 1):<br>len(haystack) - len(needle) + 1 &#x3D; 8 - 3 + 1 &#x3D; 6<br>i&#x3D;0 → haystack[i : i + 3] → haystack[0:3]<br>haystack[0:3] → “Lee” 符合！立刻 return 0</p></blockquote></li></ul></li><li><strong>D43</strong> ✅  #28 Find the Index of the First Occurrence in a String</li><li><strong>D44</strong> 🚫  #35 Search Insert Position<ul><li>找出target 是不是出現在 nums 裡？如果有，回傳它的 index；<br>如果沒有，就回傳它應該被插入的位置</li></ul></li><li><strong>D45</strong> 🚫  #35 Search Insert Position<ul><li>經典的「二分搜尋（Binary Search）」應用，時間複雜度是 O(log n)<blockquote><p>用來在「已排序的陣列」中找出某個數字<br>每次都只看一半，時間複雜度 O(log n)（非常快）</p></blockquote></li></ul></li><li><strong>D46</strong> 🚫  #35 Search Insert Position<ul><li>公式 ↓ <blockquote><p>nums &#x3D; [1, 3, 5, 6, 9, 12, 15] , target &#x3D; 9<br>設定 left &#x3D; 0，right &#x3D; 6（因為陣列長度是 7）<br>計算 mid &#x3D; (left + right) &#x2F;&#x2F; 2<br>(0 + 6) &#x2F;&#x2F; 2 &#x3D; 3 , 看 nums[3] &#x3D; 6 → 6 &lt; 9,表示 9 在右邊 → 所以更新 left &#x3D; mid + 1 &#x3D; 4<br>再算新的 mid &#x3D; (4 + 6) &#x2F;&#x2F; 2 &#x3D; 5 → nums[5] &#x3D; 12 → 12 &gt; 9，表示 9 在左邊 → 所以更新 right &#x3D; mid - 1 &#x3D; 4<br>再算新的 mid &#x3D; (4 + 4) &#x2F;&#x2F; 2 &#x3D; 4 → nums[4] &#x3D; 9 ✅ 找到了！回傳 index 4！</p></blockquote></li></ul></li><li><strong>D47</strong> 🉑  #35 Search Insert Position</li><li><strong>D48</strong> 🉑  #35 Search Insert Position</li><li><strong>D49</strong> ✅  #35 Search Insert Position</li><li><strong>D50</strong> 🚫  #58 Length of Last Word<ul><li>目標：找出最後一個單字的長度</li></ul></li><li><strong>D51</strong> 🚫  #58 Length of Last Word<ul><li>研究：.strip() &#x2F; .split()<blockquote><p><code>.strip()</code> 是把 開頭和結尾 的空白全部去掉<br><code>.split()</code> 預設是根據「空白」把句子切開成單字</p></blockquote></li></ul></li><li><strong>D52</strong> 🉑  #58 Length of Last Word<ul><li><ol><li>清除左右空白</li></ol></li><li><ol start="2"><li>用空白分割句子成單字陣列</li></ol></li><li><ol start="3"><li>取出最後一個單字，計算長度</li></ol></li></ul></li><li><strong>D53</strong> ✅  #58 Length of Last Word</li><li><strong>D54</strong> ✅  #66 Plus One<ul><li>解題：每位數字被分開存在一個 list 中, 回傳 加 1 之後 的結果 (List)<blockquote><p><code>for i in range(x, -1, -1)</code> → 從最後一個位置往前走，每次走一步，直到第一個元素。</p></blockquote></li></ul></li><li><strong>D55</strong> ✅  #3423 Maximum Difference Between Adjacent Elements in a Circular Array<ul><li>解題：求任意兩個相鄰元素之間的最大差值。<blockquote><p>取出當前元素 <code>nums[i]</code> 和下一個元素 <code>nums[(i + 1) % n]</code><br>計算絕對值 <code>abs()</code> , 然後用 <code>max()</code> 找最大的。</p></blockquote></li></ul></li><li><strong>D56</strong> 🚫  #67 Add Binary<ul><li>解題：求兩個二進位字串輸出它們相加的結果（二進位格式）。<blockquote><p><code>int(n, 2)</code>  ➜ 二進位字串 <code>n</code> 轉成 十進位整數<br><code>bin(m)</code>     ➜ 把十進位整數 <code>m</code> 轉成 二進位字串<br>  <code>(Python 的 bin() 會加上 0b 作為前綴。)</code></p></blockquote></li></ul></li><li><strong>D57</strong> 🉑  #67 Add Binary</li><li><strong>D58</strong> ✅  #67 Add Binary</li><li><strong>D59</strong> ✅  #1  Two Sum <strong>(review)</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧣 | GitHub</title>
      <link href="/2025/06/05/Aboutme/"/>
      <url>/2025/06/05/Aboutme/</url>
      
        <content type="html"><![CDATA[<h1 id="🧣-About-me"><a href="#🧣-About-me" class="headerlink" title="🧣 About me"></a>🧣 About me</h1><p><strong><a href="https://reedlin2002.github.io/desc.html">My Desc</a></strong></p><p><strong><a href="https://reedlin2002.github.io/">My Blog</a></strong>  (2025&#x2F;06&#x2F;19 轉為 Hexo + Github Pages )</p><p>主要寫 Python，偶爾碰 JavaScript 和 C#</p><p>正研究 RAG 到 LangChain (解決模型依賴和執行錯誤問題，並用Streamlit做了簡易的離線問答介面。)</p><h1 id="🛠️-Skills"><a href="#🛠️-Skills" class="headerlink" title="🛠️ Skills"></a>🛠️ Skills</h1><table align="left">  <tr>    <td align="center">      <strong style="font-size: 20px;">程式語言</strong>      <p>         <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/>         <!-- 這是一個註解，GitHub 頁面不會顯示 -->        <!-- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg" alt="c" width="40" height="40"/> -->        <!-- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/cplusplus/cplusplus-original.svg" alt="cplusplus" width="40" height="40"/> -->      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">人工智慧/機器學習</strong>      <p>         <img src="https://www.vectorlogo.zone/logos/pytorch/pytorch-icon.svg" alt="pytorch" width="40" height="40"/>        <img src="https://www.vectorlogo.zone/logos/opencv/opencv-icon.svg" alt="opencv" width="40" height="40"/>      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">網頁開發</strong>       <p>         <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/html5/html5-original-wordmark.svg" alt="html5" width="40" height="40"/>        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/css3/css3-original-wordmark.svg" alt="css3" width="40" height="40"/>        <!-- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/php/php-original.svg" alt="php" width="40" height="40"/> -->      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">版本控制</strong>       <p>         <img src="https://www.vectorlogo.zone/logos/git-scm/git-scm-icon.svg" alt="git" width="40" height="40"/>      </p>    </td>  </tr></table><br clear="both"/><h1 id="〽️-每日記錄"><a href="#〽️-每日記錄" class="headerlink" title="〽️ 每日記錄"></a>〽️ 每日記錄</h1><p><a href="https://github.com/ashutosh00710/github-readme-activity-graph"><img src="https://github-readme-activity-graph.vercel.app/graph?username=reedlin2002&theme=nord" alt="Ashutosh&#39;s github activity graph"></a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> myself </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>關於我</title>
      <link href="/2025/06/05/hello-world/"/>
      <url>/2025/06/05/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="Coding-learning-building"><a href="#Coding-learning-building" class="headerlink" title="Coding, learning, building. "></a>Coding, learning, building. <a href="https://github.com/reedlin2002"><img src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/github.svg" width="30" height="40"></a></h3><p>嘿！歡迎來到我的個人空間！我是 Jerry lin，這是我第一次嘗試架設個人網頁，會不定期記錄一些生活與學習上的小雜記。</p><h2 id="🚀-關於我"><a href="#🚀-關於我" class="headerlink" title="🚀 關於我"></a>🚀 關於我</h2><p>我是一個熱愛程式設計的大學生( 應屆畢業！ )，正在探索各種技術領域。從前端到後端，從AI到專案實作，每一步都是新的挑戰與成長。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📚-學習足跡"><a href="#📚-學習足跡" class="headerlink" title="📚 學習足跡"></a>📚 學習足跡</h2><h3 id="程式語言探索中"><a href="#程式語言探索中" class="headerlink" title="程式語言探索中"></a>程式語言探索中</h3><p>Python - 最熟悉的語言<br>C# - 專案的開發神器<br>JavaScript - 前端開發的基石<br>Vue.js &amp; React.js - 現代前端框架實戰<br>LangChain - 做智能助手、資料摘要、流程控制都能派上用場<br>RAG - 打造問答系統、知識庫搜尋</p><h3 id="持續精進"><a href="#持續精進" class="headerlink" title="持續精進"></a>持續精進</h3><p>LeetCode 刷題 - 演算法思維訓練<br>專案實作 - 理論與實務結合</p>]]></content>
      
      
      
        <tags>
            
            <tag> myself </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
