<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>📍 | LocalAIAgentAPI</title>
      <link href="/2025/07/19/LocalAIAgentAPI/"/>
      <url>/2025/07/19/LocalAIAgentAPI/</url>
      
        <content type="html"><![CDATA[<h1 id="學習專案localaiagentapi-從零開始的-ai-整合練習"><a class="markdownIt-Anchor" href="#學習專案localaiagentapi-從零開始的-ai-整合練習">#</a> 學習專案：LocalAIAgentAPI - 從零開始的 AI 整合練習</h1><blockquote><p>這週挑戰自己整合多個 AI 模型，順便為面試準備一些實戰經驗。雖然是練習專案，但收穫比想像中還要多。</p></blockquote><div id="gallery">  <a href="/images/LocalAIAgentAPI_frontend.png">    <img data-src="/images/LocalAIAgentAPI_frontend.png" alt="前端頁面" style="max-width: 600px;">  </a></div><hr><h2 id="學習目標"><a class="markdownIt-Anchor" href="#學習目標">#</a> 學習目標</h2><p>作為一個正在準備面試的開發者，我給自己設定了一個挑戰：<br>能不能在一週內整合多種 AI 模型，做出一個像樣的測試平台？</p><p>說實話，一開始我也不確定能做到什麼程度。但想說既然要學，不如就設個有挑戰性的目標：</p><ul><li>練習 .NET 8 的新特性</li><li>熟悉 AI 模型整合的流程，這應該是未來的趨勢</li><li>為面試準備一些能拿出手的作品</li><li>順便踩踩坑，累積一些真實的開發經驗</li></ul><blockquote><p>結果沒想到，這個學習過程遠比我預期的有趣。每天回家寫 code，看到專案從無到有的感覺真的很讚。</p></blockquote><h2 id="localaiagentapi"><a class="markdownIt-Anchor" href="#localaiagentapi">#</a> LocalAIAgentAPI</h2><p>這個專案基本上就是我這週學習筆記的具現化。我想透過實作來理解一些平常只能紙上談兵的問題：</p><p>怎麼在 .NET 中整合不同類型的 AI 模型？每個模型的 API 都不一樣，要怎麼設計統一的介面？REST API 的架構要怎麼設計才不會讓未來的自己想哭？前端跟後端的資料交換有哪些眉角？錯誤處理和日誌記錄該做到什麼程度？</p><p>雖然是練習專案，但我還是盡量按照真實專案的標準來做。</p><hr><h2 id="building"><a class="markdownIt-Anchor" href="#building">#</a> Building</h2><p>這一週下來，我大概涉獵了這些領域：</p><p><strong>後端架構</strong>：.NET 8 Web API、依賴注入、Middleware<br> 老實說，之前對 .NET 8 的依賴注入只是停留在「知道有這個東西」的階段，實際動手做才發現它比想像中強大很多。</p><p><strong>AI 整合</strong>：Ollama LLM、ONNX 圖片分類、Tesseract OCR<br> 每個模型的整合方式都不太一樣，這讓我對「統一介面設計」有了更深的體會。</p><p><strong>API 設計</strong>：RESTful API、輸入驗證、回應格式統一<br>如何讓不同模型的回應格式保持一致，這個問題比我想的複雜多了。</p><p><strong>前端互動</strong>：簡單的 HTML/JS、檔案上傳、即時回應<br>雖然前端不是我的強項，但現在有很多非常好用的 AI 工具 像是 ChatGPT、Claude 等，都協助我設計好的 UI 和功能。</p><p><strong>測試工具</strong>：Swagger 整合、API 測試<br> Swagger 真的是開發者的好朋友，設定完就有完整的測試介面。</p><p><strong>錯誤處理</strong>：全域異常處理、Timeout 機制<br>踩了不少坑，但也學到如何優雅地處理各種意外狀況。</p><hr><h2 id="problems"><a class="markdownIt-Anchor" href="#problems">#</a> Problems</h2><p>一週要整合這麼多東西，當然會遇到一些讓人頭痛的問題：</p><p><strong>模型載入失敗</strong>：一開始 LLAMA2 模型老是載入不起來，debug 了半天才發現是 Ollama 路徑的問題。</p><p><strong>回應時間過長</strong>：某些 LLM 推理需要很長時間，一開始沒設 Timeout，結果前端就一直等等等。體驗直接崩潰。</p><p><strong>資料格式轉換</strong>：不同模型的輸入輸出格式差異很大，光是設計統一的 API 介面就花了不少時間思考。</p><p><strong>圖片處理</strong>：從前端上傳圖片到後端處理，編碼的部分搞了我一陣子。有些知識真的要實作過才會印象深刻。</p><blockquote><p>不過每解決一個問題，就覺得又成長了一點。這大概就是寫 code 最爽的地方吧。</p></blockquote><hr><h2 id="learning"><a class="markdownIt-Anchor" href="#learning">#</a> Learning</h2><h3 id="技術層面"><a class="markdownIt-Anchor" href="#技術層面">#</a> 技術層面</h3><p>對 .NET 8 的依賴注入和 Middleware 機制有了更深入的理解。之前都是看文件學習，實際用過才知道哪些地方容易出錯。</p><p>了解了不同 AI 模型的整合方式和各自的限制。每種模型都有自己的脾氣，要花時間去摸索。</p><p>練習了 API 設計和錯誤處理的一些最佳實踐。雖然還不敢說做得很好，但至少知道該注意什麼。</p><p>熟悉了前後端資料交換的完整流程。之前都是分別學習，這次算是串起來了。</p><h3 id="軟實力"><a class="markdownIt-Anchor" href="#軟實力">#</a> 軟實力</h3><p><strong>問題解決能力</strong>：遇到問題時如何有效地搜尋資料、閱讀文件、測試假設。</p><p><strong>學習方法</strong>：如何在有限時間內快速掌握新技術的核心概念。</p><p><strong>架構思維</strong>：開始思考如何設計可維護、可擴展的系統架構。</p><hr><h3 id="這個專案"><a class="markdownIt-Anchor" href="#這個專案">#</a> 這個專案</h3><p>我會誠實地說：「這是我為了學習 AI 整合和準備面試而做的練習專案。功能相對簡單，但我把重點放在架構設計和程式碼品質上。」</p><ul><li>為什麼選擇這些技術組合？各有什麼優缺點？</li><li>開發過程中遇到的最大挑戰是什麼？如何解決的？</li><li>如果要將這個專案擴展成正式產品，需要加強哪些部分？</li><li>從這次經驗中學到最重要的一課是什麼？</li></ul><blockquote><p>我覺得展現學習態度和解決問題的思路，比專案本身的完成度更重要。</p></blockquote><hr><h2 id="next-week"><a class="markdownIt-Anchor" href="#next-week">#</a> Next Week！</h2><p>這個專案讓我嚐到了甜頭，也發現了很多可以改進的地方：</p><p><strong>程式碼重構</strong>：有些地方寫得匆忙，想練習如何重構成更乾淨的程式碼。</p><p><strong>容器化部署</strong>：嘗試用 Docker 打包，體驗現代化的部署流程。</p><hr><h2 id="專案原始碼"><a class="markdownIt-Anchor" href="#專案原始碼">#</a> 專案原始碼</h2><p>GitHub Repo: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZWRsaW4yMDAyL0xvY2FsQUlBZ2VudEFQSQ==">reedlin2002/LocalAIAgentAPI</span></p><p><strong>重要提醒</strong>：這是我的學習練習專案，程式碼品質可能還有很大改進空間，絕對不建議直接用在正式環境中。但如果你也在學習相關技術，歡迎參考或給我一些建議。</p><p>如果發現任何問題或有改進建議，也歡迎開 Issue 讓我學習。畢竟一個人閉門造車很容易有盲點。</p><hr><blockquote><p>每週挑戰一個小專案，慢慢累積實戰經驗。雖然距離真正的高手還很遠，但至少在正確的路上前進。</p></blockquote><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>  lightGallery(document.getElementById("gallery"), {    plugins: [lgZoom],    speed: 300,    zoom: true  });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>單例模式 Singleton_pattern</title>
      <link href="/2025/07/13/singleton-pattern/"/>
      <url>/2025/07/13/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="單例模式-singleton-pattern"><a class="markdownIt-Anchor" href="#單例模式-singleton-pattern">#</a> 單例模式 (Singleton Pattern)</h1><h2 id="為什麼需要-singleton"><a class="markdownIt-Anchor" href="#為什麼需要-singleton">#</a> 為什麼需要 Singleton？</h2><p>在開發大型系統時，我們經常會遇到這樣的需求：某些資源應該在整個應用程式中保持唯一性。</p><p>舉個實際例子，假設你在開發一個分散式系統，多個模組都需要記錄 Log。如果每個模組都各自創建 Logger 實例：</p><ul><li>Log 訊息會分散在不同的物件中，難以統一管理和追蹤</li><li>無法維持一致的設定（例如 Log 等級、輸出格式）</li><li>記憶體中會存在多個相同功能的物件，造成資源浪費</li></ul><p>這時候我們希望有一個全域的 Logger 管理者，所有模組都向它發送 Log 訊息。</p><p><strong>Singleton 的核心思想：確保一個類別在整個系統中只有一個實例，並提供全域的存取點。</strong></p><h2 id="沒有使用-singleton-的情況"><a class="markdownIt-Anchor" href="#沒有使用-singleton-的情況">#</a> 沒有使用 Singleton 的情況</h2><p>來看看傳統的實作方式會產生什麼問題：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模組 A</span></span><br><span class="line">logger_a = Logger()</span><br><span class="line">logger_a.log(<span class="string">&quot;A 模組初始化完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模組 B</span></span><br><span class="line">logger_b = Logger()</span><br><span class="line">logger_b.log(<span class="string">&quot;B 模組初始化完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;logger_a is logger_b:&quot;</span>, logger_a <span class="keyword">is</span> logger_b)</span><br></pre></td></tr></table></figure><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[LOG] A 模組初始化完成</span><br><span class="line">[LOG] B 模組初始化完成</span><br><span class="line">logger_a is logger_b: False</span><br></pre></td></tr></table></figure><p>可以看到，每次實例化都會產生不同的物件，這違背了我們想要統一管理的初衷。</p><h2 id="使用-singleton-pattern"><a class="markdownIt-Anchor" href="#使用-singleton-pattern">#</a> 使用 Singleton Pattern</h2><p>接下來實作 Singleton 版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLogger</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;建立 SingletonLogger 實例&quot;</span>)</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不同模組中使用</span></span><br><span class="line">logger_a = SingletonLogger()</span><br><span class="line">logger_a.log(<span class="string">&quot;A 模組初始化完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger_b = SingletonLogger()</span><br><span class="line">logger_b.log(<span class="string">&quot;B 模組初始化完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;logger_a is logger_b:&quot;</span>, logger_a <span class="keyword">is</span> logger_b)</span><br></pre></td></tr></table></figure><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建立 SingletonLogger 實例</span><br><span class="line">[LOG] A 模組初始化完成</span><br><span class="line">[LOG] B 模組初始化完成</span><br><span class="line">logger_a is logger_b: True</span><br></pre></td></tr></table></figure><p>可以看到，不論在哪個模組中實例化，都會得到相同的物件參考。</p><h2 id="實作細節說明"><a class="markdownIt-Anchor" href="#實作細節說明">#</a> 實作細節說明</h2><p>在這個實作中，我們重寫了  <code>__new__</code>  方法來控制物件的創建過程：</p><ol><li>使用類別變數  <code>_instance</code>  來儲存唯一的實例</li><li>在  <code>__new__</code>  中檢查是否已經存在實例</li><li>如果不存在，則創建新實例；如果存在，則回傳現有實例</li></ol><p>這種做法確保了無論呼叫多少次建構子，都只會有一個實例存在。</p><h2 id="適用場景"><a class="markdownIt-Anchor" href="#適用場景">#</a> 適用場景</h2><p>Singleton 適合用於以下情況：</p><p><strong>建議使用：</strong></p><ul><li>日誌系統（Logger）</li><li>設定檔管理器（Configuration Manager）</li><li>資料庫連線池（Database Connection Pool）</li><li>快取管理器（Cache Manager）</li><li>執行緒池（Thread Pool）</li></ul><p><strong>不建議使用：</strong></p><ul><li>一般業務邏輯物件</li><li>需要多個不同狀態的物件</li><li>會影響單元測試的情況</li></ul><h2 id="注意事項"><a class="markdownIt-Anchor" href="#注意事項">#</a> 注意事項</h2><p>使用 Singleton 時需要注意：</p><ol><li><strong>執行緒安全性</strong>：在多執行緒環境中，需要考慮同步問題</li><li><strong>測試困難</strong>：Singleton 會在測試之間保持狀態，可能影響測試的獨立性</li><li><strong>過度使用</strong>：不要把所有東西都做成 Singleton，這會增加系統耦合度</li></ol><p>Singleton 是一個有用的設計模式，但要在適當的場景下使用，避免為了使用設計模式而使用設計模式。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 技術筆記 </tag>
            
            <tag> (作者自學用) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>設計模式 (Software design pattern)</title>
      <link href="/2025/07/12/design-patterns/"/>
      <url>/2025/07/12/design-patterns/</url>
      
        <content type="html"><![CDATA[<h1 id="python-設計模式"><a class="markdownIt-Anchor" href="#python-設計模式">#</a> Python 設計模式</h1><p>這篇文章紀錄四種我學習過的 Python 設計模式，包含簡單範例、使用情境與心得。</p><blockquote><p><strong>四種模式</strong></p><ol><li>單例模式 (Singleton)</li><li>工廠模式 (Factory)</li><li>策略模式 (Strategy)</li><li>觀察者模式 (Observer)</li></ol></blockquote><hr><h2 id="單例模式-singleton-pattern"><a class="markdownIt-Anchor" href="#單例模式-singleton-pattern">#</a> 🟢 單例模式 Singleton Pattern</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h3><p>確保一個類別在全程只存在唯一一個實例。</p><h3 id="使用情境"><a class="markdownIt-Anchor" href="#使用情境">#</a> 使用情境</h3><ul><li>設定檔管理</li><li>資源共用 (e.g., 日誌 Logger)</li><li>全域狀態控制</li></ul><h3 id="範例程式碼"><a class="markdownIt-Anchor" href="#範例程式碼">#</a> 範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLogger</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;建立 SingletonLogger 實例&quot;</span>)</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;執行 __init__()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">log1 = SingletonLogger()</span><br><span class="line">log2 = SingletonLogger()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;log1 is log2:&quot;</span>, log1 <span class="keyword">is</span> log2)</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">建立 SingletonLogger 實例</span><br><span class="line">執行 <span class="built_in">__init__</span>()</span><br><span class="line">執行 <span class="built_in">__init__</span>()</span><br><span class="line">log1 is log2: True</span><br></pre></td></tr></table></figure><blockquote><p>在單例模式中，第一次建立 SingletonLogger () 時，會產生唯一一個「全域實例」。<br>後面不管呼叫幾次 SingletonLogger ()，都會回傳同一個物件，記憶體位置完全相同。<br>也就是說：<br>整個程式只會有一個 Logger，大家共用這個唯一的「盒子」。</p></blockquote><hr><h2 id="工廠模式-factory-pattern"><a class="markdownIt-Anchor" href="#工廠模式-factory-pattern">#</a> 🟢 工廠模式 Factory Pattern</h2><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2">#</a> 概念</h3><p>將「建立物件的邏輯」抽離到工廠方法，統一管理實例化流程。</p><h3 id="使用情境-2"><a class="markdownIt-Anchor" href="#使用情境-2">#</a> 使用情境</h3><ul><li>根據參數決定建立哪個子類別</li><li>解耦「建立物件」與「使用物件」</li></ul><h3 id="範例程式碼-2"><a class="markdownIt-Anchor" href="#範例程式碼-2">#</a> 範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span>:</span><br><span class="line">    animal_classes = &#123;</span><br><span class="line">        <span class="string">&quot;dog&quot;</span>: Dog,</span><br><span class="line">        <span class="string">&quot;cat&quot;</span>: Cat</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">animal_type</span>):</span><br><span class="line">        <span class="keyword">if</span> animal_type <span class="keyword">in</span> AnimalFactory.animal_classes:</span><br><span class="line">            <span class="keyword">return</span> AnimalFactory.animal_classes[animal_type]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;未知的動物種類&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">animal = AnimalFactory.create_animal(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(animal.speak())</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Woof</span><br></pre></td></tr></table></figure><blockquote><p>在工廠模式中，每次呼叫 AnimalFactory.create_animal ()，都會根據你給的參數，產生一個新的動物物件。<br>同一種動物（例如 Dog）呼叫多次，也會創建多個不同的 Dog 實例，彼此互不影響。<br>也就是說：<br>工廠就像流水線，每次都造出新的產品，產品彼此獨立。</p></blockquote><hr><h2 id="策略模式-strategy-pattern"><a class="markdownIt-Anchor" href="#策略模式-strategy-pattern">#</a> 🟢 策略模式 Strategy Pattern</h2><h3 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3">#</a> 概念</h3><p>將「行為策略」封裝為獨立類別，執行時依據情境決定要用哪個策略。</p><h3 id="使用情境-3"><a class="markdownIt-Anchor" href="#使用情境-3">#</a> 使用情境</h3><ul><li>動態切換演算法</li><li>行為多樣化的系統</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperCaseStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> data.upper()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LowerCaseStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> data.lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        <span class="variable language_">self</span>.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_strategy</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        <span class="variable language_">self</span>.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_strategy</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.strategy.execute(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">context = Context(UpperCaseStrategy())</span><br><span class="line"><span class="built_in">print</span>(context.execute_strategy(<span class="string">&quot;Hello Strategy&quot;</span>))</span><br><span class="line"></span><br><span class="line">context.set_strategy(LowerCaseStrategy())</span><br><span class="line"><span class="built_in">print</span>(context.execute_strategy(<span class="string">&quot;Hello Strategy&quot;</span>))</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO STRATEGY</span><br><span class="line">hello strategy</span><br></pre></td></tr></table></figure><blockquote><p>在策略模式中，每次 CreditCardPayment () 都會建立一個新的「策略物件」，<br>ShoppingCart () 也每次產生一個新的購物車，<br>不會共用同一個實例，也就是說：<br>策略物件和購物車都是獨立的！</p></blockquote><hr><h2 id="觀察者模式-observer-pattern"><a class="markdownIt-Anchor" href="#觀察者模式-observer-pattern">#</a> 🟢 觀察者模式 Observer Pattern</h2><h3 id="概念-4"><a class="markdownIt-Anchor" href="#概念-4">#</a> 概念</h3><p>當主題狀態改變時，自動通知所有依賴它的觀察者。</p><h3 id="使用情境-4"><a class="markdownIt-Anchor" href="#使用情境-4">#</a> 使用情境</h3><ul><li>事件通知</li><li>資料監聽</li><li>訂閱 / 發布系統</li></ul><h3 id="範例程式碼-3"><a class="markdownIt-Anchor" href="#範例程式碼-3">#</a> 範例程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 收到通知: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_observer</span>(<span class="params">self, observer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify_observers</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> <span class="variable language_">self</span>.observers:</span><br><span class="line">            observer.update(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試</span></span><br><span class="line">chat_room = ChatRoom()</span><br><span class="line">user1 = User(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">user2 = User(<span class="string">&quot;小美&quot;</span>)</span><br><span class="line"></span><br><span class="line">chat_room.add_observer(user1)</span><br><span class="line">chat_room.add_observer(user2)</span><br><span class="line"></span><br><span class="line">chat_room.notify_observers(<span class="string">&quot;今天有新活動！&quot;</span>)</span><br></pre></td></tr></table></figure><p>執行輸出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明 收到通知: 今天有新活動！</span><br><span class="line">小美 收到通知: 今天有新活動！</span><br></pre></td></tr></table></figure><blockquote><p>在觀察者模式中，每次 User () 都會建立一個新的「觀察者物件」，<br>ChatRoom () 也可以建立多個聊天室，彼此沒有關聯。<br>當聊天室呼叫 notify_observers () 時，會通知它自己「清單裡的觀察者」。<br>也就是說：<br>每個聊天室都維護自己的訂閱清單，觀察者和主題都是獨立物件，沒有共享同一個實例。</p></blockquote><hr><h2 id="小結"><a class="markdownIt-Anchor" href="#小結">#</a> ✨ 小結</h2><p>這四種模式是物件導向程式設計中最經典的設計模式：</p><ul><li>單例：只有一個實例</li><li>工廠：統一建立流程</li><li>策略：行為可替換</li><li>觀察者：自動通知訂閱者</li></ul><table><thead><tr><th style="text-align:center">設計模式</th><th style="text-align:center">主要特點</th><th style="text-align:center">適用情境</th><th style="text-align:center">物件產生方式</th></tr></thead><tbody><tr><td style="text-align:center"><strong>單例模式</strong></td><td style="text-align:center">保證一個類別只有一個實例，並提供全局唯一的存取點。</td><td style="text-align:center">需要全局唯一資源或管理器，例如設定管理、日誌記錄器等。</td><td style="text-align:center">第一次建立時創建，之後重複使用同一實例。</td></tr><tr><td style="text-align:center"><strong>工廠模式</strong></td><td style="text-align:center">封裝物件創建邏輯，根據參數決定要建立哪一種物件，讓使用者不用直接接觸具體類別。</td><td style="text-align:center">需要根據條件動態生成不同類型物件，降低使用者與物件具體類別的耦合。</td><td style="text-align:center">每次呼叫都會新建不同物件。</td></tr><tr><td style="text-align:center"><strong>策略模式</strong></td><td style="text-align:center">將算法或行為封裝成獨立物件，並讓它們可互換，使得系統在運行時能動態切換算法。</td><td style="text-align:center">需要靈活切換算法或行為，避免條件分支過多。</td><td style="text-align:center">每次使用時新建策略物件，不同策略互相獨立。</td></tr><tr><td style="text-align:center"><strong>觀察者模式</strong></td><td style="text-align:center">建立一對多關係，當主題狀態改變時，自動通知所有訂閱者，達成鬆耦合的事件傳遞。</td><td style="text-align:center">事件驅動、發布訂閱系統、即時更新通知等場景。</td><td style="text-align:center">主題與觀察者皆可多次建立，互為獨立物件。</td></tr></tbody></table><p>未來如果專案規模變大，這些模式能幫助：</p><ul><li>✅ 降低耦合度（大家不再黏在一起）</li></ul><blockquote><p>這些模式會強迫你把各種責任分散開來，<br>物件之間不需要互相知道彼此內部細節，<br>就像不同部門只透過「公開的接口」溝通，<br>大幅減少改一個功能導致整個系統崩潰的風險。</p></blockquote><ul><li>✅ 提高可維護性（東西更好修、更好改）</li></ul><blockquote><p>有了清晰的模式，每個部分都只負責一種角色，<br>你要修 bug 或調整邏輯時，可以聚焦在單一地方，<br>不用像無頭蒼蠅一樣到處追查影響範圍。<br>也方便新人上手，因為架構清楚一目了然。</p></blockquote><ul><li>✅ 提升擴展彈性（新功能不再痛苦）</li></ul><blockquote><p>當業務成長、需求變化時，<br>這些模式讓你用「替換」或「新增」的方式擴展功能，<br>不必動原本穩定的代碼：</p></blockquote><ul><li>工廠模式：多增加一種產品類別即可</li><li>策略模式：多一個演算法就 plug-in</li><li>觀察者模式：隨時加訂閱者、移訂閱者</li><li>單例模式：確保全域只有一個資源</li></ul><hr><p>技術與應用方法：<br>Python（OOP 與 Design Pattern）、VS Code（Python Extension）、互動式 CLI（範例測試）</p><h2 id="心得"><a class="markdownIt-Anchor" href="#心得">#</a> 📝心得：</h2><blockquote><p>一開始對  <code>__new__()</code> 、工廠模式的「字典映射類別」還有策略模式「注入策略物件」這種寫法有點陌生，看起來超抽象，不太確定「為什麼要多繞一層」，但慢慢測試、比對記憶體位置，就理解到它們的用意，這次練習也算是把「抽象的設計模式」變成「具體的練習案例」，實際跑一遍後真的對日後專案會有很大幫助，不管是要降低耦合度、提高可維護性、還是做功能擴展，都比單純 procedural code 更直覺清晰。如果未來要用到更大型的框架（像 Django、Flask、.NET Core），這些模式也能直接套用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技術筆記 </tag>
            
            <tag> (作者自學用) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌐 | 網站健康監控平台</title>
      <link href="/2025/07/05/UrlHealthMonitor/"/>
      <url>/2025/07/05/UrlHealthMonitor/</url>
      
        <content type="html"><![CDATA[<h1 id="net-url-health-monitor-以-docker-部署的網站監控服務"><a class="markdownIt-Anchor" href="#net-url-health-monitor-以-docker-部署的網站監控服務">#</a> 🚀 .NET URL Health Monitor - 以 Docker 部署的網站監控服務</h1><blockquote><p>這是一個基於 .NET 8 的 URL 健康檢查服務，提供即時監控結果與可視化儀表板，支援 Docker 容器化部署。</p></blockquote><p>►  「 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZWRsaW4yMDAyL1VybEhlYWx0aE1vbml0b3I=">GITHUB</span> 」</p><hr><h2 id="專案緣起"><a class="markdownIt-Anchor" href="#專案緣起">#</a> 💡 專案緣起</h2><p>在現代化的網站運維中，服務的可用性監控至關重要。在日常網站維運中，我們常需要定期檢查多個 URL 的可用性，並記錄歷史狀態供追蹤。本專案希望：</p><ul><li>自動化監控：每 30 秒自動檢查所有註冊的 URL</li><li>視覺化儀表板：以簡易 Web UI 呈現最近監控結果</li><li>簡易管理：CLI 指令快速管理監控清單、使用 SQLite 儲存歷史資料</li><li>提供容器化部署：Docker 一鍵部署，跨平台支援</li></ul><hr><h2 id="️-專案技術"><a class="markdownIt-Anchor" href="#️-專案技術">#</a> 🛠️ 專案技術</h2><p>🟢 後端核心</p><blockquote><p>框架：.NET 8 Worker Service + <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> Minimal API<br> 語言：C#（Async/Await + 依賴注入）<br>資料庫：SQLite 輕量級資料庫</p></blockquote><p>🟡 測試與品質</p><blockquote><p>測試框架：xUnit + FluentAssertions<br> 開發方法：採用 TDD 思維</p></blockquote><p>🟣 前端</p><blockquote><p>介面：簡易 Web Dashboard<br> 技術：HTML5 + CSS3 + Vanilla JavaScript</p></blockquote><p>🟠 部署運維</p><blockquote><p>容器化：Docker<br> 環境支援：Linux / Windows /macOS</p></blockquote><hr><h2 id="️-執行方式"><a class="markdownIt-Anchor" href="#️-執行方式">#</a> ⚙️ 執行方式</h2><h3 id="開發模式-本機執行"><a class="markdownIt-Anchor" href="#開發模式-本機執行">#</a> 開發模式 (本機執行)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dotnet run -- add &lt;URL&gt;       # 新增要監控的 URL</span><br><span class="line">dotnet run -- list            # 列出所有 URL</span><br><span class="line">dotnet run -- remove &lt;ID&gt;     # 移除指定 URL</span><br><span class="line">dotnet run -- serve           # 啟動 Web UI</span><br></pre></td></tr></table></figure><p>打開 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAw">http://localhost:5000</span> 查看 Dashboard。</p><h3 id="docker-部署"><a class="markdownIt-Anchor" href="#docker-部署">#</a> Docker 部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 建置映像</span><br><span class="line">docker build -t urlhealthmonitor .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 執行容器</span><br><span class="line">docker run -d -p 5001:5000 --name urlhealthmonitor urlhealthmonitor</span><br></pre></td></tr></table></figure><p>打開 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAx">http://localhost:5001</span> 查看 Dashboard。</p><hr><h2 id="實際示範"><a class="markdownIt-Anchor" href="#實際示範">#</a> 🌐 實際示範</h2><div id="gallery">  <a href="/images/UrlHealthMonitor-01.png">    <img data-src="/images/UrlHealthMonitor-01.png" alt="記帳頁面" style="max-width: 600px;">  </a></div><hr><h2 id="tdd-測試"><a class="markdownIt-Anchor" href="#tdd-測試">#</a> 🧪 TDD 測試</h2><h3 id="測試"><a class="markdownIt-Anchor" href="#測試">#</a> 測試</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test</span><br></pre></td></tr></table></figure><p>測試範圍：</p><ul><li>HTTP 請求狀態檢查</li><li>超時處理</li><li>資料庫操作</li></ul><hr><h2 id="未來擴展"><a class="markdownIt-Anchor" href="#未來擴展">#</a> 🚀 未來擴展</h2><ul><li>RESTful API 支援</li><li>整合通知 (EMAIL / LINE)</li><li>監控數據視覺化</li></ul><hr><p>技術與應用方法：<br>.NET 8、C#（Async/Await + 依賴注入）、SQLite、xUnit + FluentAssertions（TDD 開發流程）、Docker、HttpClient（網站監控）、CLI 、JavaScript + HTML/CSS</p><h2 id="心得"><a class="markdownIt-Anchor" href="#心得">#</a> 📝 心得</h2><blockquote><p>針對 TDD、HTTP 協議這兩個技術練習了這個「HTTP 狀態碼偵測器」，在撰寫程式碼的過程中因為使用的是很久沒碰的 C# 一開始確實有些生疏，經常忘記變數宣告的語法規則，但隨著練習逐漸找回手感。在 Docker 部屬上，常常遇到檔案不知道放哪裡的問題，不過經過一番 ChatGPT 的協助和一番研究也是弄好了～也靠著 TDD 學會了更可靠的程式碼，先用測試再寫功能，確保程式碼符合預期，減少 BUG，培養良好的開發習慣</p></blockquote><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>  lightGallery(document.getElementById("gallery"), {    plugins: [lgZoom],    speed: 300,    zoom: true  });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧠 | 聊天機器人</title>
      <link href="/2025/06/25/ollama/"/>
      <url>/2025/06/25/ollama/</url>
      
        <content type="html"><![CDATA[<h1 id="用-ollama-langchain-打造本地-ai-工具型-agent含-rag-文件問答"><a class="markdownIt-Anchor" href="#用-ollama-langchain-打造本地-ai-工具型-agent含-rag-文件問答">#</a> 用 Ollama + LangChain 打造本地 AI 工具型 Agent（含 RAG 文件問答）</h1><blockquote><p>這是一個我為了學習與實驗所做的小型 side project，目的是了解如何在本地端結合 LLM、LangChain 工具框架與 RAG（檢篩式問答）系統，實作出一個能夠回答問題、查天氣、計算數學，甚至查詢本地知識檔案的智能助手。</p></blockquote><hr><h2 id="專案目標"><a class="markdownIt-Anchor" href="#專案目標">#</a> 🔧 專案目標</h2><blockquote><p>✫️ 建立一個 AI 助手系統，具備：</p></blockquote><ul><li>多工具整合能力（如計算器、天氣查詢）</li><li>基於本地文字檔的知識問答功能（RAG）</li><li>使用自己裝好模型的 Ollama + LangChain Agent 結構</li></ul><hr><h2 id="系統流程圖"><a class="markdownIt-Anchor" href="#系統流程圖">#</a> 系統流程圖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用者輸入問題</span><br><span class="line">    ↓</span><br><span class="line">判斷是否需呼叫工具？</span><br><span class="line">    ↓</span><br><span class="line">【需要工具的流程】                                           【不需要工具的流程】</span><br><span class="line">LangChain Agent 分析                 直接呼叫 LLM → LLM 生成回答 → 輸出結果給使用者</span><br><span class="line">    ↓</span><br><span class="line">選擇對應 Tool</span><br><span class="line">    ├ Calculator Tool</span><br><span class="line">    │</span><br><span class="line">    ├ Get Weather Tool  </span><br><span class="line">    │</span><br><span class="line">    └ RAG Tool</span><br><span class="line">        ├ TextLoader 載入檔案</span><br><span class="line">        ├ Text Splitter 切段</span><br><span class="line">        ├ HuggingFaceEmbeddings 向量化</span><br><span class="line">        └ FAISS 向量資料庫檢索</span><br><span class="line">    ↓</span><br><span class="line">Ollama LLM (Mistral)</span><br><span class="line">    ↓</span><br><span class="line">生成回答</span><br><span class="line">    ↓</span><br><span class="line">輸出結果給使用者</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="套件與技術"><a class="markdownIt-Anchor" href="#套件與技術">#</a> 套件與技術</h2><table><thead><tr><th>技術</th><th>用途</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly93d3cubGFuZ2NoYWluLmNvbS8=">LangChain</span></td><td>組合 Agent 與工具</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9vbGxhbWEuY29tLw==">Ollama</span> (Mistral)</td><td>本地執行的大語言模型</td></tr><tr><td><code>Tool</code>  (LangChain)</td><td>包裝可被 Agent 呼叫的功能</td></tr><tr><td><code>RetrievalQA</code></td><td>建立基於文字檔的問答鏈</td></tr><tr><td><code>FAISS</code></td><td>高效的向量資料庫</td></tr><tr><td><code>HuggingFaceEmbeddings</code></td><td>將文本轉換為向量的埋入模型</td></tr><tr><td><code>TextLoader</code> ,  <code>CharacterTextSplitter</code></td><td>處理本地文件內容</td></tr></tbody></table><hr><h3 id="核心程式"><a class="markdownIt-Anchor" href="#核心程式">#</a> 核心程式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ⭐️ LLM 模型（使用 Ollama + Mistral）</span></span><br><span class="line">llm = OllamaLLM(model=<span class="string">&quot;mistral&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⭐️ 建立工具：Calculator / Get Weather</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculator</span>(<span class="params">query</span>): <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">eval</span>(query))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weather</span>(<span class="params">city</span>): <span class="keyword">return</span> &#123;<span class="string">&quot;台北&quot;</span>:<span class="string">&quot;晴天30度&quot;</span>&#125;.get(city, <span class="string">&quot;查無資料&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⭐️ RAG 工具：透過 FAISS 向量庫查詢本地 data.txt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_rag_tool</span>():</span><br><span class="line">    loader = TextLoader(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">    docs = loader.load()</span><br><span class="line">    splits = CharacterTextSplitter(chunk_size=<span class="number">500</span>).split_documents(docs)</span><br><span class="line">    embeddings = HuggingFaceEmbeddings()</span><br><span class="line">    vectorstore = FAISS.from_documents(splits, embeddings)</span><br><span class="line">    retriever = vectorstore.as_retriever()</span><br><span class="line">    rag_chain = RetrievalQA.from_chain_type(llm, retriever=retriever)</span><br><span class="line">    <span class="keyword">return</span> Tool(name=<span class="string">&quot;rag_tool&quot;</span>, func=rag_chain.run, description=<span class="string">&quot;查詢本地知識文件&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="整合-tool-與-agent"><a class="markdownIt-Anchor" href="#整合-tool-與-agent">#</a> 整合 Tool 與 Agent</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tools = [</span><br><span class="line">    Tool.from_function(<span class="string">&quot;calculator&quot;</span>, calculator, <span class="string">&quot;數學計算&quot;</span>),</span><br><span class="line">    Tool.from_function(<span class="string">&quot;get_weather&quot;</span>, get_weather, <span class="string">&quot;天氣查詢&quot;</span>),</span><br><span class="line">    build_rag_tool()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    agent_type=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,</span><br><span class="line">    handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">    verbose=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a class="markdownIt-Anchor" href="#測試">#</a> 測試</h2><h3 id="查詢天氣台北"><a class="markdownIt-Anchor" href="#查詢天氣台北">#</a> 查詢天氣：台北</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：查台北天氣</span><br><span class="line">🧩 使用 [Agent] 處理中...</span><br><span class="line"></span><br><span class="line">Action: get_weather</span><br><span class="line">Action Input: <span class="string">&#x27;Taipei&#x27;</span></span><br><span class="line">Observation: 晴天，30 度</span><br><span class="line">Final Answer: 晴天，30 度</span><br></pre></td></tr></table></figure><div id="gallery1">  <a href="/images/ollama-Taipei.png">    <img data-src="/images/ollama-Taipei.png" alt="查詢天氣：台北" style="max-width: 600px;">  </a></div><hr><h3 id="查詢天氣高雄"><a class="markdownIt-Anchor" href="#查詢天氣高雄">#</a> 查詢天氣：高雄</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：高雄幾度</span><br><span class="line"></span><br><span class="line">Action: get_weather</span><br><span class="line">Action Input: <span class="string">&#x27;高雄&#x27;</span></span><br><span class="line">Observation: 小雨，27 度</span><br><span class="line">Final Answer: 高雄今天是小雨且27度。</span><br></pre></td></tr></table></figure><div id="gallery2">  <a href="/images/ollama-KAO.png">    <img data-src="/images/ollama-KAO.png" alt="查詢天氣：高雄" style="max-width: 600px;">  </a></div><hr><h3 id="數學運算"><a class="markdownIt-Anchor" href="#數學運算">#</a> 數學運算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：12 * 3 + 5 是多少？</span><br><span class="line"></span><br><span class="line">Action: calculator</span><br><span class="line">Action Input: <span class="string">&#x27;12 * 3 + 5&#x27;</span></span><br><span class="line">Observation: 45</span><br><span class="line">Final Answer: 結果為45。</span><br></pre></td></tr></table></figure><div id="gallery3">  <a href="/images/ollama-math.png">    <img data-src="/images/ollama-math.png" alt="數學運算" style="max-width: 600px;">  </a></div><hr><h3 id="問文件內容"><a class="markdownIt-Anchor" href="#問文件內容">#</a> 問文件內容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：文件內容有提到什麼？</span><br><span class="line"></span><br><span class="line">Action: rag_tool</span><br><span class="line">Observation: 文件提到了台灣、台北、自然風景、語言（台語、閩南語、客家話）、夜市與珍珠奶茶等。</span><br><span class="line">Final Answer: 這份文件提到了台灣、台北、自然風景、文化與語言、以及夜市文化。</span><br></pre></td></tr></table></figure><div id="gallery4">  <a href="/images/ollama-RAG.png">    <img data-src="/images/ollama-RAG.png" alt="問文件內容" style="max-width: 600px;">  </a></div><hr><h3 id="自然對話"><a class="markdownIt-Anchor" href="#自然對話">#</a> 自然對話</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❓請輸入問題：你好</span><br><span class="line"></span><br><span class="line">💬 使用 LLM 直接回答...</span><br><span class="line">🤖 回答：您好！讓我有幸為您提供服務。如果您有任何問題，請隨時告知，我會盡力幫助您解決。</span><br></pre></td></tr></table></figure><div id="gallery5">  <a href="/images/ollama-LLM.png">    <img data-src="/images/ollama-LLM.png" alt="自然對話" style="max-width: 600px;">  </a></div><hr><h2 id="結構"><a class="markdownIt-Anchor" href="#結構">#</a> 📁 結構</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my-ollama/</span><br><span class="line">│</span><br><span class="line">├── main.py</span><br><span class="line">├── data.txt       ← 本地知識庫文字檔</span><br><span class="line">├── .venv/         ← 虛擬環境</span><br><span class="line">├── requirements.txt</span><br></pre></td></tr></table></figure><hr><p>技術包含：<br>Python、LangChain、Ollama、Mistral 模型、FAISS、HuggingFace Embeddings、RetrievalQA、自訂工具函數（Calculator、Get Weather）</p><h2 id="心得"><a class="markdownIt-Anchor" href="#心得">#</a> 📝 心得</h2><blockquote><p>第一次接觸 LLM、LangChain、Agent 花了 2、3 天完成這個小應用。<br>這個 project 幫助我：</p></blockquote><ul><li>熟悉 LangChain 中 Tool/Agent 的用法</li><li>練習本地模型 Ollama 的載入與使用</li><li>理解 RAG 的流程從文件切分到檢篩的設計邏輯</li></ul><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>    lightGallery(document.getElementById("gallery1"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery2"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery3"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery4"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });    lightGallery(document.getElementById("gallery5"), {    plugins: [lgZoom],    speed: 300,    zoom: true    });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🤖 | 記帳小管家</title>
      <link href="/2025/06/18/expenses/"/>
      <url>/2025/06/18/expenses/</url>
      
        <content type="html"><![CDATA[<h1 id="一個結合-react-前端與-flask-後端的個人記帳專案"><a class="markdownIt-Anchor" href="#一個結合-react-前端與-flask-後端的個人記帳專案">#</a> 一個結合 React 前端與 Flask 後端的個人記帳專案</h1><blockquote><p>基於 Flask + React，快速打造可視化、具本地儲存功能的個人記帳工具，部署在 Render 免費平台。</p></blockquote><div id="gallery">  <a href="/images/expenses_1.png">    <img data-src="/images/expenses_1.png" alt="記帳頁面" style="max-width: 600px;">  </a></div><hr><h2 id="執行目標"><a class="markdownIt-Anchor" href="#執行目標">#</a> 執行目標</h2><p>希望做出一款簡單的記帳小工具，具有以下功能：</p><ul><li>支援每日紀錄多筆支出</li><li>直覺的欄位輸入介面</li><li>統計支出、圖表呈現</li><li>可依週切換檢視區間</li><li>支援本地儲存（localStorage）</li><li>無須登入註冊，輕量、單機可用</li></ul><h2 id="技術使用"><a class="markdownIt-Anchor" href="#技術使用">#</a> 技術使用</h2><ul><li><strong>Flask</strong>: Python 後端 Web Framework</li><li><strong>HTML + React (CDN)</strong>: 前端創建主畫面</li><li><strong>Babel (CDN)</strong>: 讓我們直接在 HTML 中操作 JSX</li><li><strong>CSS</strong>: 自定義樣式</li><li><strong><span class="exturl" data-url="aHR0cDovL1JlbmRlci5jb20=">Render.com</span></strong>: 免費部署 Platform</li></ul><h3 id="flask-後端"><a class="markdownIt-Anchor" href="#flask-後端">#</a> Flask 後端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template  <span class="comment"># 匯入 Flask 框架與頁面渲染函式</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 匯入 os 模組，用於抓取環境變數</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  <span class="comment"># 初始化 Flask 應用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)  </span><span class="comment"># 當用戶訪問根目錄 `/` 時</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)  <span class="comment"># 回傳前端頁面（templates/index.html）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 讓 Flask 可以在本地測試，也能被 Render 部署（抓環境變數 PORT）</span></span><br><span class="line">    port = <span class="built_in">int</span>(os.environ.get(<span class="string">&quot;PORT&quot;</span>, <span class="number">5000</span>))</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=port)</span><br></pre></td></tr></table></figure><h3 id="前端-html-react"><a class="markdownIt-Anchor" href="#前端-html-react">#</a> 前端 HTML + React</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;css/style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- React &amp; Babel CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Chart.js for data visualization --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 載入應用程式主程式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;js/app.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>React 使用 CDN 形式加載，用  <code>babel</code>  直接執行 JSX 程式</p></blockquote><h2 id="react-應用程式-core"><a class="markdownIt-Anchor" href="#react-應用程式-core">#</a> React 應用程式 core</h2><h3 id="資料儲存方式"><a class="markdownIt-Anchor" href="#資料儲存方式">#</a> 資料儲存方式</h3><table><thead><tr><th>元件</th><th>功能說明</th></tr></thead><tbody><tr><td><code>App</code></td><td>主控元件，負責整體狀態與資料流處理</td></tr><tr><td><code>ExpenseForm</code></td><td>表單元件，讓使用者輸入支出項目與金額</td></tr><tr><td><code>ExpenseList</code></td><td>顯示當日支出紀錄，並可即時動態更新</td></tr><tr><td><code>WeeklyChart</code></td><td>使用柱狀圖呈現每日支出金額，支援週次切換與點擊查看</td></tr></tbody></table><h3 id="架構設計"><a class="markdownIt-Anchor" href="#架構設計">#</a> 架構設計</h3><ul><li>資料儲存：所有紀錄保存在 localStorage，依照日期分類。</li><li>畫面互動：輸入資料即時更新列表與圖表，並保留在本地。</li><li>視覺化統計：使用 Chart.js 呈現每日總支出，支援週次切換與點擊查看。</li></ul><p>技術包含：<br>Python、Flask、HTML、React、Babel、JavaScript、Chart.js、CSS、localStorage、<span class="exturl" data-url="aHR0cDovL1JlbmRlci5jb20=">Render.com</span></p><h2 id="心得"><a class="markdownIt-Anchor" href="#心得">#</a> 📝 心得</h2><blockquote><p>這是一個簡單的 Flask + React 應用，Side Project。</p></blockquote><link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/css/lightgallery-bundle.min.css"/><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script>  lightGallery(document.getElementById("gallery"), {    plugins: [lgZoom],    speed: 300,    zoom: true  });</script>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📕 | PDF Reader</title>
      <link href="/2025/06/09/program/"/>
      <url>/2025/06/09/program/</url>
      
        <content type="html"><![CDATA[<h1 id="pdf-reader"><a class="markdownIt-Anchor" href="#pdf-reader">#</a> PDF Reader</h1><blockquote><p>這是一個利用 RAG（Retrieval-Augmented Generation），做的 PDF 閱讀工具，方便從 PDF 文件中查詢資訊。</p></blockquote><hr><h2 id="技術架構"><a class="markdownIt-Anchor" href="#技術架構">#</a> 技術架構</h2><ul><li>使用 Streamlit 做前端互動頁面，讓使用者上傳 PDF 並輸入問題。</li><li>使用 PyPDF2 讀取 PDF 內容，jieba 進行分段。</li><li>使用 SentenceTransformer 將文本轉成向量，再用 FAISS 建立向量搜尋索引。</li><li>利用 Hugging Face 中文問答模型，從搜尋到的相關段落中找答案。</li><li>將答案與參考段落顯示給使用者。</li></ul><p>RAG 技術透過檢索（Retrieval）+ 增強上下文（Augmentation）+ 生成回答（Generation）三步驟，讓模型根據提供的內容產出準確的答案。</p><hr><h2 id="rag-流程-簡易"><a class="markdownIt-Anchor" href="#rag-流程-簡易">#</a> 🧩 RAG 流程 (簡易)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提問 → 檢索相關內容 → 合併為上下文 → 模型生成回答</span><br></pre></td></tr></table></figure><h3 id="1-retrieval檢索"><a class="markdownIt-Anchor" href="#1-retrieval檢索">#</a> 1. Retrieval（檢索）</h3><ul><li>將 PDF 切成段落並建立向量表示（TF-IDF 或 embedding）</li><li>使用 cosine similarity 找出與問題最相關的段落</li></ul><h3 id="2-augmentation增強"><a class="markdownIt-Anchor" href="#2-augmentation增強">#</a> 2. Augmentation（增強）</h3><ul><li>將相關段落合併成上下文內容</li><li>與問題一起輸入給模型</li></ul><h3 id="3-generation生成"><a class="markdownIt-Anchor" href="#3-generation生成">#</a> 3. Generation（生成）</h3><ul><li>使用 Hugging Face 的中文 QA 模型回答問題</li></ul><hr><h2 id="系統流程圖"><a class="markdownIt-Anchor" href="#系統流程圖">#</a> 系統流程圖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[PDF 上傳] → [文字解析] → [中文分段]</span><br><span class="line">                        ↓</span><br><span class="line">           [段落向量化（TF-IDF）]</span><br><span class="line">                        ↓</span><br><span class="line">         [使用者提問 → 問題向量化]</span><br><span class="line">                        ↓</span><br><span class="line">         [計算相似度 → 取前 3 段]</span><br><span class="line">                        ↓</span><br><span class="line">        [合併上下文 + question]</span><br><span class="line">                        ↓</span><br><span class="line">         [丟進 HuggingFace QA 模型]</span><br><span class="line">                        ↓</span><br><span class="line">                 [產生回答]</span><br></pre></td></tr></table></figure><hr><h2 id="程式"><a class="markdownIt-Anchor" href="#程式">#</a> 程式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立段落的 TF-IDF 向量庫</span></span><br><span class="line">chunk_vectors = vectorizer.fit_transform(chunks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將使用者問題向量化</span></span><br><span class="line">query_vec = vectorizer.transform([user_question])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算問題與各段落相似度</span></span><br><span class="line">similarities = cosine_similarity(query_vec, chunk_vectors)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得前三個最高相似度段落索引</span></span><br><span class="line">top_indices = similarities.argsort()[-<span class="number">3</span>:][::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合成上下文</span></span><br><span class="line">top_chunks = [chunks[i] <span class="keyword">for</span> i <span class="keyword">in</span> top_indices]</span><br><span class="line">context = <span class="string">&quot;\n&quot;</span>.join(top_chunks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 丟給問答模型產生答案</span></span><br><span class="line">result = qa_pipeline(&#123;<span class="string">&quot;question&quot;</span>: user_question, <span class="string">&quot;context&quot;</span>: context&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>技術包含：<br>Python、Streamlit、PyPDF2、jieba、SentenceTransformers、FAISS、Hugging Face Transformers</p><h2 id="心得"><a class="markdownIt-Anchor" href="#心得">#</a> 📝 心得</h2><blockquote><p><strong>備註</strong>：這個程式是我學習 RAG 技術的初步嘗試，所以還有很多能夠優化的地方，請多指教。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📌 | LeetCode 學習記錄</title>
      <link href="/2025/06/06/dailyleetcode/"/>
      <url>/2025/06/06/dailyleetcode/</url>
      
        <content type="html"><![CDATA[<p>程式能力的提升離不開持續的練習。我會在這裡分享：</p><p>每日筆記 - 自己對題目的理解與應用<br>心得分享 - 刷題過程中的進度與收穫</p><table><thead><tr><th>✅</th><th>🉑</th><th>🚫</th></tr></thead><tbody><tr><td><strong>了解並寫出</strong></td><td><strong>寫出但不清楚</strong></td><td><strong>寫不出來</strong></td></tr></tbody></table><p>📌 <strong>LeetCode 記錄</strong></p><ul><li><strong>D1</strong> 🉑  #1  Two Sum <em>(GPT)</em></li><li><strong>D2</strong> 🉑  #9  Palindrome Number <em>(GPT)</em></li><li><strong>D3</strong> ✅  #13 Roman to Integer <em>(GPT)</em></li><li><strong>D4</strong> ✅  #1  Two Sum</li><li><strong>D5</strong> ☕ <strong>休息</strong></li><li><strong>D6</strong> ✅  #9  Palindrome<ul><li><code>[::-1]</code>  ← Python 能用來順序相反</li></ul></li><li><strong>D7</strong> 🉑  #14 Longest Common Prefix<ul><li><code>startswith(prefix)</code>  ← 檢查字串是否「以 prefix 開頭」</li></ul></li><li><strong>D8</strong> 🉑  #14 Longest Common Prefix<ul><li><code>if not 某東西:</code>  ← 檢查 “某東西” 是否為空，如果是就執行</li></ul></li><li><strong>D9</strong> 🉑  #14 Longest Common Prefix<ul><li><code>while not 某東西:</code>  ← 檢查 “某東西” 為 True/False，如果為 False 就執行</li></ul></li><li><strong>D10</strong> ✅  #14 Longest Common Prefix</li><li><strong>D11</strong> ✅  #14 Longest Common Prefix <em>(複習)</em></li><li><strong>D12</strong> 🚫  #20 Valid Parentheses</li><li><strong>D13</strong> 🚫  #20 Valid Parentheses<ul><li><code>&#123;&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;&#125;</code>  ← 嘗試理解 mapping 對應關係</li></ul></li><li><strong>D14</strong> ☕ <strong>休息</strong></li><li><strong>D15</strong> 🚫  #20 Valid Parentheses<ul><li><code>&#123;&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;&#125;</code>  ← 嘗試理解 mapping 對應關係</li></ul></li><li><strong>D16</strong> 🚫  #20 Valid Parentheses<ul><li><code>for i in s:</code>  ← 直接遍歷字串中的每個字元</li></ul></li><li><strong>D17</strong> 🚫  #20 Valid Parentheses<ul><li><code>if i in mapping:</code>  ← 檢查 i 是否是右括號（ <code>)</code> , <code>]</code> ,  <code>&#125;</code> ）</li><li><code>mapping[&quot;)&quot;]</code>   ← 會得到  <code>(</code> (從 mapping 這個對應關係中)</li><li><code>stack[-1]</code>  意思是 stack 的堆疊的最上層 EX:  <code>x=[ 10, 20, 30] x[-1]=30 x[-2]=20 x[-3]=10</code></li></ul></li><li><strong>D18</strong> 🉑  #20 Valid Parentheses</li><li><strong>D19</strong> 🉑  #20 Valid Parentheses<ul><li><code>stack.append</code>   ← 將資料放入堆疊頂端</li><li><code>stack.pop</code>      ← 將堆疊頂端資料移除</li></ul></li><li><strong>D20</strong> 🉑  #20 Valid Parentheses</li><li><strong>D21</strong> 🉑  #20 Valid Parentheses</li><li><strong>D22</strong> ✅  #20 Valid Parentheses</li><li><strong>D23</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>2025/05/07 回歸繼續寫<blockquote><p>self.val = val        # 節點的數值，例如 1、2、3<br>self.next = next      # 指向下一個節點的指標</p></blockquote></li></ul></li><li><strong>D24</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>ListNode(1) -&gt; ListNode(3) -&gt; ListNode(5)<blockquote><p>每個節點 (ListNode) 裡面都有：<br>.val：存放數值（1、3、5）<br>.next：指向下一個節點（或 None 表示結尾）</p></blockquote></li></ul></li><li><strong>D25</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>list1 = 1 -&gt; 3 -&gt; 5、list2 = 2 -&gt; 4 -&gt; 6<blockquote><p>比較 1 和 2 → 接 1 → list1 向前 → 結果：1<br> 比較 3 和 2 → 接 2 → list2 向前 → 結果：1 → 2<br> 比較 3 和 4 → 接 3 → …<br> 一直到兩邊都走完 → 合併完成</p></blockquote></li></ul></li><li><strong>D26</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>🔚 dummy 是儲存「整條串列的起點」<br><br>🔧 current.next 是「不斷接節點的位置」</li></ul></li><li><strong>D27</strong> 🚫  #21 Merge Two Sorted Lists<ul><li>✔️ dummy 是假節點，current 是用來構建新串列的指標</li><li>✔️ while 迴圈比較 list1 和 list2：<blockquote><p>每次比較 .val，把比較小的節點接到 current.next<br> 然後那邊的 list 移動到下一個節點（list1 = list1.next），再讓 current 自己也往前移（current = current.next）</p></blockquote></li><li>✔️ 接剩下沒比完的節點，最後 return dummy.next 而不是 dummy</li></ul></li><li><strong>D28</strong> 🉑  #21 Merge Two Sorted Lists</li><li><strong>D29</strong> ✅  #21 Merge Two Sorted Lists</li><li><strong>D30</strong> ✅  #21 Merge Two Sorted Lists (review)</li><li><strong>D31</strong> ✅  #75 Sort Colors (Daily Question)</li><li><strong>D32</strong> 🚫  #26 Remove Duplicates from Sorted Array<ul><li>目標為輸出不重複結果 (應該是用 i、j 解決)</li></ul></li><li><strong>D33</strong> 🚫  #26 Remove Duplicates from Sorted Array<ul><li>找出不重複的元素</li><li>for j in range(1, len(nums)):<blockquote><p>從第二個元素開始找 j 是掃描指標</p></blockquote></li><li>if nums[j] != nums[i]:<blockquote><p>比較當前掃描到的 nums [j] 跟上次保留的 nums [i]<br> 如果不一樣 → 代表找到一個 新的不重複元素</p></blockquote></li><li>i += 1<br>nums[i] = nums[j]</li></ul><blockquote><p>把這個新元素「放到前面」來取代舊的重複元素</p></blockquote></li><li><strong>D34</strong> 🉑  #26 Remove Duplicates from Sorted Array</li><li><strong>D35</strong> 🉑  #26 Remove Duplicates from Sorted Array<ul><li>邊掃描、邊把不重複的元素往前搬<blockquote><p>nums [0] 到 nums [i] 是 不重複且排序好的</p></blockquote></li></ul></li><li><strong>D36</strong> ✅  #26 Remove Duplicates from Sorted Array</li><li><strong>D37</strong> 🚫  #27 Remove Element</li><li><strong>D38</strong> 🉑  #27 Remove Element<ul><li>就地 (in-place) 移除所有等於 val 的元素，並回傳「移除後的陣列長度」</li></ul></li><li><strong>D39</strong> ✅  #27 Remove Element</li><li><strong>D40</strong> 🚫  #28 Find the Index of the First Occurrence in a String<ul><li>找出一段小字串，第一次在大字串中出現的位置</li></ul></li><li><strong>D41</strong> 🉑  #28 Find the Index of the First Occurrence in a String<ul><li>判斷<blockquote><p>haystack = “TCodeLee”<br>haystack [0:3] → 取第 0、1、2 的字 → “TCo”<br>haystack [1:4] → 取第 1、2、3 的字 → “Cod”</p></blockquote></li></ul></li><li><strong>D42</strong> 🉑  #28 Find the Index of the First Occurrence in a String<ul><li>假設 hatstack:LeetCode , needle:Lee<blockquote><p>for i in range(len(haystack) - len(needle) + 1):<br>len(haystack) - len(needle) + 1 = 8 - 3 + 1 = 6<br>i=0 → haystack[i : i + 3] → haystack[0:3]<br> haystack [0:3] → “Lee” 符合！立刻 return 0</p></blockquote></li></ul></li><li><strong>D43</strong> ✅  #28 Find the Index of the First Occurrence in a String</li><li><strong>D44</strong> 🚫  #35 Search Insert Position<ul><li>找出 target 是不是出現在 nums 裡？如果有，回傳它的 index；<br>如果沒有，就回傳它應該被插入的位置</li></ul></li><li><strong>D45</strong> 🚫  #35 Search Insert Position<ul><li>經典的「二分搜尋（Binary Search）」應用，時間複雜度是 O (log n)<blockquote><p>用來在「已排序的陣列」中找出某個數字<br>每次都只看一半，時間複雜度 O (log n)（非常快）</p></blockquote></li></ul></li><li><strong>D46</strong> 🚫  #35 Search Insert Position<ul><li>公式 ↓<blockquote><p>nums = [1, 3, 5, 6, 9, 12, 15] , target = 9<br> 設定 left = 0，right = 6（因為陣列長度是 7）<br>計算 mid = (left + right) // 2<br> (0 + 6) // 2 = 3 , 看 nums [3] = 6 → 6 &lt; 9, 表示 9 在右邊 → 所以更新 left = mid + 1 = 4<br> 再算新的 mid = (4 + 6) // 2 = 5 → nums [5] = 12 → 12 &gt; 9，表示 9 在左邊 → 所以更新 right = mid - 1 = 4<br> 再算新的 mid = (4 + 4) // 2 = 4 → nums [4] = 9 ✅ 找到了！回傳 index 4！</p></blockquote></li></ul></li><li><strong>D47</strong> 🉑  #35 Search Insert Position</li><li><strong>D48</strong> 🉑  #35 Search Insert Position</li><li><strong>D49</strong> ✅  #35 Search Insert Position</li><li><strong>D50</strong> 🚫  #58 Length of Last Word<ul><li>目標：找出最後一個單字的長度</li></ul></li><li><strong>D51</strong> 🚫  #58 Length of Last Word<ul><li>研究：.strip () /.split ()<blockquote><p><code>.strip()</code>  是把 開頭和結尾 的空白全部去掉<br> <code>.split()</code>  預設是根據「空白」把句子切開成單字</p></blockquote></li></ul></li><li><strong>D52</strong> 🉑  #58 Length of Last Word<ul><li><ol><li>清除左右空白</li></ol></li><li><ol start="2"><li>用空白分割句子成單字陣列</li></ol></li><li><ol start="3"><li>取出最後一個單字，計算長度</li></ol></li></ul></li><li><strong>D53</strong> ✅  #58 Length of Last Word</li><li><strong>D54</strong> ✅  #66 Plus One<ul><li>解題：每位數字被分開存在一個 list 中，回傳 加 1 之後 的結果 (List)<blockquote><p><code>for i in range(x, -1, -1)</code>  → 從最後一個位置往前走，每次走一步，直到第一個元素。</p></blockquote></li></ul></li><li><strong>D55</strong> ✅  #3423 Maximum Difference Between Adjacent Elements in a Circular Array<ul><li>解題：求任意兩個相鄰元素之間的最大差值。<blockquote><p>取出當前元素  <code>nums[i]</code>  和下一個元素  <code>nums[(i + 1) % n]</code> <br> 計算絕對值  <code>abs()</code>  , 然後用  <code>max()</code>  找最大的。</p></blockquote></li></ul></li><li><strong>D56</strong> 🚫  #67 Add Binary<ul><li>解題：求兩個二進位字串輸出它們相加的結果（二進位格式）。<blockquote><p><code>int(n, 2)</code>   ➜ 二進位字串  <code>n</code>  轉成 十進位整數<br> <code>bin(m)</code>      ➜ 把十進位整數  <code>m</code>  轉成 二進位字串<br> <code>(Python 的 bin() 會加上 0b 作為前綴。)</code></p></blockquote></li></ul></li><li><strong>D57</strong> 🉑  #67 Add Binary</li><li><strong>D58</strong> ✅  #67 Add Binary</li><li><strong>D59</strong> ✅  #1  Two Sum <strong>(review)</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧣 | GitHub</title>
      <link href="/2025/06/05/Aboutme/"/>
      <url>/2025/06/05/Aboutme/</url>
      
        <content type="html"><![CDATA[<h1 id="about-me"><a class="markdownIt-Anchor" href="#about-me">#</a> 🧣 About me</h1><p><strong><a href="https://reedlin2002.github.io/desc.html">My Desc</a></strong></p><p><strong><a href="https://reedlin2002.github.io/">My Blog</a></strong>  (2025/06/19 轉為 Hexo + Github Pages)</p><p>主要寫 Python，偶爾碰 JavaScript 和 C#</p><p>正研究 RAG 到 LangChain (解決模型依賴和執行錯誤問題，並用 Streamlit 做了簡易的離線問答介面。)</p><h1 id="️-skills"><a class="markdownIt-Anchor" href="#️-skills">#</a> 🛠️ Skills</h1><table align="left">  <tr>    <td align="center">      <strong style="font-size: 20px;">程式語言</strong>      <p>         <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/>         <!-- 這是一個註解，GitHub 頁面不會顯示 -->        <!-- <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg" alt="c" width="40" height="40"/> -->        <!-- <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/cplusplus/cplusplus-original.svg" alt="cplusplus" width="40" height="40"/> -->      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">人工智慧/機器學習</strong>      <p>         <img data-src="https://www.vectorlogo.zone/logos/pytorch/pytorch-icon.svg" alt="pytorch" width="40" height="40"/>        <img data-src="https://www.vectorlogo.zone/logos/opencv/opencv-icon.svg" alt="opencv" width="40" height="40"/>      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">網頁開發</strong>       <p>         <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/html5/html5-original-wordmark.svg" alt="html5" width="40" height="40"/>        <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/css3/css3-original-wordmark.svg" alt="css3" width="40" height="40"/>        <!-- <img data-src="https://raw.githubusercontent.com/devicons/devicon/master/icons/php/php-original.svg" alt="php" width="40" height="40"/> -->      </p>    </td>    <td align="center">      <strong style="font-size: 20px;">版本控制</strong>       <p>         <img data-src="https://www.vectorlogo.zone/logos/git-scm/git-scm-icon.svg" alt="git" width="40" height="40"/>      </p>    </td>  </tr></table><br clear="both"/><h1 id="️-每日記錄"><a class="markdownIt-Anchor" href="#️-每日記錄">#</a> 〽️ 每日記錄</h1><p><a href="https://github.com/ashutosh00710/github-readme-activity-graph"><img data-src="https://github-readme-activity-graph.vercel.app/graph?username=reedlin2002&amp;theme=nord" alt="Ashutosh's github activity graph"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> myself </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
