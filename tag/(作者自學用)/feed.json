{
    "version": "https://jsonfeed.org/version/1",
    "title": "Reedlin2002 • All posts by \"(作者自學用)\" tag",
    "description": "用來記錄學習與開發的歷程",
    "home_page_url": "https://reedlin2002.github.io",
    "items": [
        {
            "id": "https://reedlin2002.github.io/2025/07/13/singleton-pattern/",
            "url": "https://reedlin2002.github.io/2025/07/13/singleton-pattern/",
            "title": "單例模式 Singleton_pattern",
            "date_published": "2025-07-13T08:16:17.000Z",
            "content_html": "<h1 id=\"單例模式-singleton-pattern\"><a class=\"markdownIt-Anchor\" href=\"#單例模式-singleton-pattern\">#</a> 單例模式 (Singleton Pattern)</h1>\n<h2 id=\"為什麼需要-singleton\"><a class=\"markdownIt-Anchor\" href=\"#為什麼需要-singleton\">#</a> 為什麼需要 Singleton？</h2>\n<p>在開發大型系統時，我們經常會遇到這樣的需求：某些資源應該在整個應用程式中保持唯一性。</p>\n<p>舉個實際例子，假設你在開發一個分散式系統，多個模組都需要記錄 Log。如果每個模組都各自創建 Logger 實例：</p>\n<ul>\n<li>Log 訊息會分散在不同的物件中，難以統一管理和追蹤</li>\n<li>無法維持一致的設定（例如 Log 等級、輸出格式）</li>\n<li>記憶體中會存在多個相同功能的物件，造成資源浪費</li>\n</ul>\n<p>這時候我們希望有一個全域的 Logger 管理者，所有模組都向它發送 Log 訊息。</p>\n<p><strong>Singleton 的核心思想：確保一個類別在整個系統中只有一個實例，並提供全域的存取點。</strong></p>\n<h2 id=\"沒有使用-singleton-的情況\"><a class=\"markdownIt-Anchor\" href=\"#沒有使用-singleton-的情況\">#</a> 沒有使用 Singleton 的情況</h2>\n<p>來看看傳統的實作方式會產生什麼問題：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">log</span>(<span class=\"params\">self, msg</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[LOG] <span class=\"subst\">&#123;msg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模組 A</span></span><br><span class=\"line\">logger_a = Logger()</span><br><span class=\"line\">logger_a.log(<span class=\"string\">&quot;A 模組初始化完成&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模組 B</span></span><br><span class=\"line\">logger_b = Logger()</span><br><span class=\"line\">logger_b.log(<span class=\"string\">&quot;B 模組初始化完成&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;logger_a is logger_b:&quot;</span>, logger_a <span class=\"keyword\">is</span> logger_b)</span><br></pre></td></tr></table></figure>\n<p>執行結果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[LOG] A 模組初始化完成</span><br><span class=\"line\">[LOG] B 模組初始化完成</span><br><span class=\"line\">logger_a is logger_b: False</span><br></pre></td></tr></table></figure>\n<p>可以看到，每次實例化都會產生不同的物件，這違背了我們想要統一管理的初衷。</p>\n<h2 id=\"使用-singleton-pattern\"><a class=\"markdownIt-Anchor\" href=\"#使用-singleton-pattern\">#</a> 使用 Singleton Pattern</h2>\n<p>接下來實作 Singleton 版本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingletonLogger</span>:</span><br><span class=\"line\">    _instance = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls._instance <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;建立 SingletonLogger 實例&quot;</span>)</span><br><span class=\"line\">            cls._instance = <span class=\"built_in\">super</span>().__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">log</span>(<span class=\"params\">self, msg</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[LOG] <span class=\"subst\">&#123;msg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在不同模組中使用</span></span><br><span class=\"line\">logger_a = SingletonLogger()</span><br><span class=\"line\">logger_a.log(<span class=\"string\">&quot;A 模組初始化完成&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">logger_b = SingletonLogger()</span><br><span class=\"line\">logger_b.log(<span class=\"string\">&quot;B 模組初始化完成&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;logger_a is logger_b:&quot;</span>, logger_a <span class=\"keyword\">is</span> logger_b)</span><br></pre></td></tr></table></figure>\n<p>執行結果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">建立 SingletonLogger 實例</span><br><span class=\"line\">[LOG] A 模組初始化完成</span><br><span class=\"line\">[LOG] B 模組初始化完成</span><br><span class=\"line\">logger_a is logger_b: True</span><br></pre></td></tr></table></figure>\n<p>可以看到，不論在哪個模組中實例化，都會得到相同的物件參考。</p>\n<h2 id=\"實作細節說明\"><a class=\"markdownIt-Anchor\" href=\"#實作細節說明\">#</a> 實作細節說明</h2>\n<p>在這個實作中，我們重寫了  <code>__new__</code>  方法來控制物件的創建過程：</p>\n<ol>\n<li>使用類別變數  <code>_instance</code>  來儲存唯一的實例</li>\n<li>在  <code>__new__</code>  中檢查是否已經存在實例</li>\n<li>如果不存在，則創建新實例；如果存在，則回傳現有實例</li>\n</ol>\n<p>這種做法確保了無論呼叫多少次建構子，都只會有一個實例存在。</p>\n<h2 id=\"適用場景\"><a class=\"markdownIt-Anchor\" href=\"#適用場景\">#</a> 適用場景</h2>\n<p>Singleton 適合用於以下情況：</p>\n<p><strong>建議使用：</strong></p>\n<ul>\n<li>日誌系統（Logger）</li>\n<li>設定檔管理器（Configuration Manager）</li>\n<li>資料庫連線池（Database Connection Pool）</li>\n<li>快取管理器（Cache Manager）</li>\n<li>執行緒池（Thread Pool）</li>\n</ul>\n<p><strong>不建議使用：</strong></p>\n<ul>\n<li>一般業務邏輯物件</li>\n<li>需要多個不同狀態的物件</li>\n<li>會影響單元測試的情況</li>\n</ul>\n<h2 id=\"注意事項\"><a class=\"markdownIt-Anchor\" href=\"#注意事項\">#</a> 注意事項</h2>\n<p>使用 Singleton 時需要注意：</p>\n<ol>\n<li><strong>執行緒安全性</strong>：在多執行緒環境中，需要考慮同步問題</li>\n<li><strong>測試困難</strong>：Singleton 會在測試之間保持狀態，可能影響測試的獨立性</li>\n<li><strong>過度使用</strong>：不要把所有東西都做成 Singleton，這會增加系統耦合度</li>\n</ol>\n<p>Singleton 是一個有用的設計模式，但要在適當的場景下使用，避免為了使用設計模式而使用設計模式。</p>\n<hr>\n",
            "tags": [
                "技術筆記",
                "(作者自學用)"
            ]
        },
        {
            "id": "https://reedlin2002.github.io/2025/07/12/design-patterns/",
            "url": "https://reedlin2002.github.io/2025/07/12/design-patterns/",
            "title": "設計模式 (Software design pattern)",
            "date_published": "2025-07-12T06:36:56.000Z",
            "content_html": "<h1 id=\"python-設計模式\"><a class=\"markdownIt-Anchor\" href=\"#python-設計模式\">#</a> Python 設計模式</h1>\n<p>這篇文章紀錄四種我學習過的 Python 設計模式，包含簡單範例、使用情境與心得。</p>\n<blockquote>\n<p><strong>四種模式</strong></p>\n<ol>\n<li>單例模式 (Singleton)</li>\n<li>工廠模式 (Factory)</li>\n<li>策略模式 (Strategy)</li>\n<li>觀察者模式 (Observer)</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"單例模式-singleton-pattern\"><a class=\"markdownIt-Anchor\" href=\"#單例模式-singleton-pattern\">#</a> 🟢 單例模式 Singleton Pattern</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>確保一個類別在全程只存在唯一一個實例。</p>\n<h3 id=\"使用情境\"><a class=\"markdownIt-Anchor\" href=\"#使用情境\">#</a> 使用情境</h3>\n<ul>\n<li>設定檔管理</li>\n<li>資源共用 (e.g., 日誌 Logger)</li>\n<li>全域狀態控制</li>\n</ul>\n<h3 id=\"範例程式碼\"><a class=\"markdownIt-Anchor\" href=\"#範例程式碼\">#</a> 範例程式碼</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingletonLogger</span>:</span><br><span class=\"line\">    _instance = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cls._instance:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;建立 SingletonLogger 實例&quot;</span>)</span><br><span class=\"line\">            cls._instance = <span class=\"built_in\">super</span>().__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;執行 __init__()&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 測試</span></span><br><span class=\"line\">log1 = SingletonLogger()</span><br><span class=\"line\">log2 = SingletonLogger()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;log1 is log2:&quot;</span>, log1 <span class=\"keyword\">is</span> log2)</span><br></pre></td></tr></table></figure>\n<p>執行輸出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">建立 SingletonLogger 實例</span><br><span class=\"line\">執行 <span class=\"built_in\">__init__</span>()</span><br><span class=\"line\">執行 <span class=\"built_in\">__init__</span>()</span><br><span class=\"line\">log1 is log2: True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在單例模式中，第一次建立 SingletonLogger () 時，會產生唯一一個「全域實例」。<br>\n後面不管呼叫幾次 SingletonLogger ()，都會回傳同一個物件，記憶體位置完全相同。<br>\n也就是說：<br>\n整個程式只會有一個 Logger，大家共用這個唯一的「盒子」。</p>\n</blockquote>\n<hr>\n<h2 id=\"工廠模式-factory-pattern\"><a class=\"markdownIt-Anchor\" href=\"#工廠模式-factory-pattern\">#</a> 🟢 工廠模式 Factory Pattern</h2>\n<h3 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h3>\n<p>將「建立物件的邏輯」抽離到工廠方法，統一管理實例化流程。</p>\n<h3 id=\"使用情境-2\"><a class=\"markdownIt-Anchor\" href=\"#使用情境-2\">#</a> 使用情境</h3>\n<ul>\n<li>根據參數決定建立哪個子類別</li>\n<li>解耦「建立物件」與「使用物件」</li>\n</ul>\n<h3 id=\"範例程式碼-2\"><a class=\"markdownIt-Anchor\" href=\"#範例程式碼-2\">#</a> 範例程式碼</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">speak</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Woof&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">speak</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Meow&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AnimalFactory</span>:</span><br><span class=\"line\">    animal_classes = &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;dog&quot;</span>: Dog,</span><br><span class=\"line\">        <span class=\"string\">&quot;cat&quot;</span>: Cat</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">create_animal</span>(<span class=\"params\">animal_type</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> animal_type <span class=\"keyword\">in</span> AnimalFactory.animal_classes:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> AnimalFactory.animal_classes[animal_type]()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;未知的動物種類&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 測試</span></span><br><span class=\"line\">animal = AnimalFactory.create_animal(<span class=\"string\">&quot;dog&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(animal.speak())</span><br></pre></td></tr></table></figure>\n<p>執行輸出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Woof</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在工廠模式中，每次呼叫 AnimalFactory.create_animal ()，都會根據你給的參數，產生一個新的動物物件。<br>\n同一種動物（例如 Dog）呼叫多次，也會創建多個不同的 Dog 實例，彼此互不影響。<br>\n也就是說：<br>\n工廠就像流水線，每次都造出新的產品，產品彼此獨立。</p>\n</blockquote>\n<hr>\n<h2 id=\"策略模式-strategy-pattern\"><a class=\"markdownIt-Anchor\" href=\"#策略模式-strategy-pattern\">#</a> 🟢 策略模式 Strategy Pattern</h2>\n<h3 id=\"概念-3\"><a class=\"markdownIt-Anchor\" href=\"#概念-3\">#</a> 概念</h3>\n<p>將「行為策略」封裝為獨立類別，執行時依據情境決定要用哪個策略。</p>\n<h3 id=\"使用情境-3\"><a class=\"markdownIt-Anchor\" href=\"#使用情境-3\">#</a> 使用情境</h3>\n<ul>\n<li>動態切換演算法</li>\n<li>行為多樣化的系統</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Strategy</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperCaseStrategy</span>(<span class=\"title class_ inherited__\">Strategy</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data.upper()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LowerCaseStrategy</span>(<span class=\"title class_ inherited__\">Strategy</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data.lower()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Context</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, strategy</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.strategy = strategy</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">set_strategy</span>(<span class=\"params\">self, strategy</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.strategy = strategy</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute_strategy</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.strategy.execute(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 測試</span></span><br><span class=\"line\">context = Context(UpperCaseStrategy())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(context.execute_strategy(<span class=\"string\">&quot;Hello Strategy&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">context.set_strategy(LowerCaseStrategy())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(context.execute_strategy(<span class=\"string\">&quot;Hello Strategy&quot;</span>))</span><br></pre></td></tr></table></figure>\n<p>執行輸出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELLO STRATEGY</span><br><span class=\"line\">hello strategy</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在策略模式中，每次 CreditCardPayment () 都會建立一個新的「策略物件」，<br>\nShoppingCart () 也每次產生一個新的購物車，<br>\n不會共用同一個實例，也就是說：<br>\n策略物件和購物車都是獨立的！</p>\n</blockquote>\n<hr>\n<h2 id=\"觀察者模式-observer-pattern\"><a class=\"markdownIt-Anchor\" href=\"#觀察者模式-observer-pattern\">#</a> 🟢 觀察者模式 Observer Pattern</h2>\n<h3 id=\"概念-4\"><a class=\"markdownIt-Anchor\" href=\"#概念-4\">#</a> 概念</h3>\n<p>當主題狀態改變時，自動通知所有依賴它的觀察者。</p>\n<h3 id=\"使用情境-4\"><a class=\"markdownIt-Anchor\" href=\"#使用情境-4\">#</a> 使用情境</h3>\n<ul>\n<li>事件通知</li>\n<li>資料監聽</li>\n<li>訂閱 / 發布系統</li>\n</ul>\n<h3 id=\"範例程式碼-3\"><a class=\"markdownIt-Anchor\" href=\"#範例程式碼-3\">#</a> 範例程式碼</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, message</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span>(<span class=\"title class_ inherited__\">Observer</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, message</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;self.name&#125;</span> 收到通知: <span class=\"subst\">&#123;message&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ChatRoom</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.observers = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">add_observer</span>(<span class=\"params\">self, observer</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.observers.append(observer)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">notify_observers</span>(<span class=\"params\">self, message</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> observer <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.observers:</span><br><span class=\"line\">            observer.update(message)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 測試</span></span><br><span class=\"line\">chat_room = ChatRoom()</span><br><span class=\"line\">user1 = User(<span class=\"string\">&quot;小明&quot;</span>)</span><br><span class=\"line\">user2 = User(<span class=\"string\">&quot;小美&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">chat_room.add_observer(user1)</span><br><span class=\"line\">chat_room.add_observer(user2)</span><br><span class=\"line\"></span><br><span class=\"line\">chat_room.notify_observers(<span class=\"string\">&quot;今天有新活動！&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>執行輸出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">小明 收到通知: 今天有新活動！</span><br><span class=\"line\">小美 收到通知: 今天有新活動！</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在觀察者模式中，每次 User () 都會建立一個新的「觀察者物件」，<br>\nChatRoom () 也可以建立多個聊天室，彼此沒有關聯。<br>\n當聊天室呼叫 notify_observers () 時，會通知它自己「清單裡的觀察者」。<br>\n也就是說：<br>\n每個聊天室都維護自己的訂閱清單，觀察者和主題都是獨立物件，沒有共享同一個實例。</p>\n</blockquote>\n<hr>\n<h2 id=\"小結\"><a class=\"markdownIt-Anchor\" href=\"#小結\">#</a> ✨ 小結</h2>\n<p>這四種模式是物件導向程式設計中最經典的設計模式：</p>\n<ul>\n<li>單例：只有一個實例</li>\n<li>工廠：統一建立流程</li>\n<li>策略：行為可替換</li>\n<li>觀察者：自動通知訂閱者</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">設計模式</th>\n<th style=\"text-align:center\">主要特點</th>\n<th style=\"text-align:center\">適用情境</th>\n<th style=\"text-align:center\">物件產生方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>單例模式</strong></td>\n<td style=\"text-align:center\">保證一個類別只有一個實例，並提供全局唯一的存取點。</td>\n<td style=\"text-align:center\">需要全局唯一資源或管理器，例如設定管理、日誌記錄器等。</td>\n<td style=\"text-align:center\">第一次建立時創建，之後重複使用同一實例。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>工廠模式</strong></td>\n<td style=\"text-align:center\">封裝物件創建邏輯，根據參數決定要建立哪一種物件，讓使用者不用直接接觸具體類別。</td>\n<td style=\"text-align:center\">需要根據條件動態生成不同類型物件，降低使用者與物件具體類別的耦合。</td>\n<td style=\"text-align:center\">每次呼叫都會新建不同物件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>策略模式</strong></td>\n<td style=\"text-align:center\">將算法或行為封裝成獨立物件，並讓它們可互換，使得系統在運行時能動態切換算法。</td>\n<td style=\"text-align:center\">需要靈活切換算法或行為，避免條件分支過多。</td>\n<td style=\"text-align:center\">每次使用時新建策略物件，不同策略互相獨立。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>觀察者模式</strong></td>\n<td style=\"text-align:center\">建立一對多關係，當主題狀態改變時，自動通知所有訂閱者，達成鬆耦合的事件傳遞。</td>\n<td style=\"text-align:center\">事件驅動、發布訂閱系統、即時更新通知等場景。</td>\n<td style=\"text-align:center\">主題與觀察者皆可多次建立，互為獨立物件。</td>\n</tr>\n</tbody>\n</table>\n<p>未來如果專案規模變大，這些模式能幫助：</p>\n<ul>\n<li>✅ 降低耦合度（大家不再黏在一起）</li>\n</ul>\n<blockquote>\n<p>這些模式會強迫你把各種責任分散開來，<br>\n物件之間不需要互相知道彼此內部細節，<br>\n就像不同部門只透過「公開的接口」溝通，<br>\n大幅減少改一個功能導致整個系統崩潰的風險。</p>\n</blockquote>\n<ul>\n<li>✅ 提高可維護性（東西更好修、更好改）</li>\n</ul>\n<blockquote>\n<p>有了清晰的模式，每個部分都只負責一種角色，<br>\n你要修 bug 或調整邏輯時，可以聚焦在單一地方，<br>\n不用像無頭蒼蠅一樣到處追查影響範圍。<br>\n也方便新人上手，因為架構清楚一目了然。</p>\n</blockquote>\n<ul>\n<li>✅ 提升擴展彈性（新功能不再痛苦）</li>\n</ul>\n<blockquote>\n<p>當業務成長、需求變化時，<br>\n這些模式讓你用「替換」或「新增」的方式擴展功能，<br>\n不必動原本穩定的代碼：</p>\n</blockquote>\n<ul>\n<li>工廠模式：多增加一種產品類別即可</li>\n<li>策略模式：多一個演算法就 plug-in</li>\n<li>觀察者模式：隨時加訂閱者、移訂閱者</li>\n<li>單例模式：確保全域只有一個資源</li>\n</ul>\n<hr>\n<p>技術與應用方法：<br>\nPython（OOP 與 Design Pattern）、VS Code（Python Extension）、互動式 CLI（範例測試）</p>\n<h2 id=\"心得\"><a class=\"markdownIt-Anchor\" href=\"#心得\">#</a> 📝心得：</h2>\n<blockquote>\n<p>一開始對  <code>__new__()</code> 、工廠模式的「字典映射類別」還有策略模式「注入策略物件」這種寫法有點陌生，看起來超抽象，不太確定「為什麼要多繞一層」，但慢慢測試、比對記憶體位置，就理解到它們的用意，這次練習也算是把「抽象的設計模式」變成「具體的練習案例」，實際跑一遍後真的對日後專案會有很大幫助，不管是要降低耦合度、提高可維護性、還是做功能擴展，都比單純 procedural code 更直覺清晰。如果未來要用到更大型的框架（像 Django、Flask、.NET Core），這些模式也能直接套用。</p>\n</blockquote>\n",
            "tags": [
                "技術筆記",
                "(作者自學用)"
            ]
        }
    ]
}